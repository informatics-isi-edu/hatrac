{
    "docs": [
        {
            "location": "/INSTALL/", 
            "text": "Hatrac Installation\n\n\nHatrac\n (pronounced\n\"hat rack\") is a simple object storage service for web-based,\ndata-oriented collaboration.\n\n\nInstall code\n\n\n\n\nCheck out the development code from GitHub.\n\n\nInstall prerequisites:\n\n\nApache HTTPD\n\n\nPostgreSQL\n\n\nPython\n\n\nweb.py\n\n\nwebauthn2\n\n\nInstall hatrac Python package from top-level of development code.\n\n\npython setup.py install\n\n\nRun \nbasic tests\n or continue to \nconfigure the web stack\n.\n\n\n\n\nBasic testing\n\n\nYou can perform some local testing of Hatrac without configuring the\nwhole web service stack, daemon account, nor daemon account configuration data:\n\n\n# make sure Hatrac is installed\n% python setup.py install\n\n# get rid of any previous test data\n% dropdb hatrac_test\n% rm -rf hatrac_test_data\n\n# create empty test database\n% createdb hatrac_test\n\n# run tests\n% python test/smoketest.py\n\n\n\nThe test script should run to completion without printing anything. If\nit encounters errors, diagnostics will be printed and the script will\nexit.  You MUST start with an empty test database and empty test data\ndirectory prior to each run of the test.\n\n\nConfigure web stack\n\n\nThese steps continue following the basic\n\ncode installation\n. For installations using SE-Linux,\nplease see \nworking with SE-Linux\n below.\n\n\n\n\nCreate \nhatrac\n daemon account.\n\n\nE.g. \nuseradd --create-home --system hatrac\n (as root)\n\n\nCreate \nhatrac\n PostgreSQL role.\n\n\nE.g. \ncreateuser -d hatrac\n (as PostgreSQL superuser)\n\n\nConfigure \n~hatrac/hatrac_config.json\n\n\nSee \nexample Hatrac configuration\n below.\n\n\nCreate and initialize \nhatrac\n database.\n\n\nE.g. \ncreatedb hatrac\n (as \nhatrac\n user)\n\n\nE.g. \nhatrac-deploy your_username_or_group\n (as \nhatrac\n user)\n\n\nCreate file storage directory under Apache\n\n\nE.g. \nmkdir /var/www/hatrac \n chown hatrac /var/www/hatrac\n (as root)\n\n\nConfigure \n~hatrac/webauthn2_config.json\n\n\nSee \nexample Webauthn2 configuration\n below.\n\n\nConfigure \nmod_wsgi\n to run Hatrac\n\n\nSee \nexample Apache configuration\n below.\n\n\n\n\nThe \nhatrac-deploy\n step above depends on having a proper\n\n~hatrac/hatrac_config.json\n file already populated and an empty\ndatabase already created. It simply initializes the database schema.\n\n\nIf working in a SELinux environment see section below to SELinux specific additional steps needed before running the tests\n\n\nExample Hatrac configuration\n\n\nThis configuration works on a Fedora and Ubuntu host for a filesystem deployment:\n\n\n{\n    \"storage_backend\": \"filesystem\",\n    \"storage_path\": \"/var/www/hatrac\",\n    \"database_type\": \"postgres\",\n    \"database_dsn\": \"dbname=hatrac\",\n    \"database_schema\": \"hatrac\",\n    \"database_max_retries\": 5,\n    \"403_html\": \"\nhtml\nbody\nh1\nAccess Forbidden\n/h1\np\n%(message)s\n/p\n/body\n/html\n\",\n    \"401_html\": \"\nhtml\nbody\nh1\nAuthentication Required\n/h1\np\n%(message)s\n/p\n/body\n/html\n\"\n}\n\n\n\nThis configuration works for an Amazon AWS S3 deployment:\n\n\n{\n    \"backend\": \"amazons3\",\n    \"s3_bucket\" : \nS3_BUCKET_NAME\n,\n    \"s3_connection\": {\n    \"aws_access_key_id\" : \nAWS_ACCESS_KEY_ID\n,\n        \"aws_secret_access_key\": \nAWS_SECRET_ACCESS_KEY\n\n    },\n    \"database_type\": \"postgres\",\n    \"database_dsb\": \"dbname=hatrac\",\n    \"database_schema\": \"hatrac\",\n    \"database_max_retries\": 5\n}\n\n\n\nREST API testing\n\n\nYou can perform system testing of the whole web service stack, if\nconfigured with cookie-based authentication (such as using a companion\nERMrest installation as described in the subsequent configration\nexamples of this document):\n\n\n# manually create a session cookie\n% curl -b cookie -c cookie \\\n   -d username=testuser -d password=testpassword \\\n   https://$(hostname)/ermrest/auth/session\n\n# run the test script\n% COOKIES=cookie bash test/rest-smoketest.sh\n\n\n\nExample Webauthn2 configuration\n\n\nThis configuration allows Hatrac to share an existing Webauthn2\ndeployment from an ERMrest installation (if ERMrest is configured with\nthe same cookie name and path settings):\n\n\n{\n      \"require_client\": true,\n      \"require_attributes\": true, \n      \"listusers_permit\": [\"admin\"], \n      \"listattributes_permit\": [\"admin\"], \n      \"manageusers_permit\": [\"admin\"], \n      \"manageattributes_permit\": [\"admin\"],\n\n      \"session_expiration_minutes\": 30, \n      \"def_passwd_len\": 10, \n      \"hash_passwd_reps\": 1000,\n\n      \"sessionids_provider\": \"webcookie\", \n      \"sessionstates_provider\": \"database\", \n      \"clients_provider\": \"database\", \n      \"attributes_provider\": \"database\",\n\n      \"handler_uri_usersession\": \"/ermrest/authn/session\",\n\n      \"web_cookie_name\": \"ermrest\", \n      \"web_cookie_path\": \"/\", \n      \"web_cookie_secure\": true, \n      \"setheader\": false,\n\n      \"database_schema\": \"webauthn2\", \n      \"database_type\": \"postgres\", \n      \"database_dsn\": \"dbname=ermrest\", \n      \"database_max_retries\": 5\n}\n\n\n\nYou will also have to grant ermrest permissions to the hatrac role:\nGRANT ermrest TO hatrac ; (as postgres user)\n\n\nNote\n: at present, Hatrac does not expose any Webauthn2 REST APIs\nso you MUST share an existing deployment as above if you want to use a\nlocal account and session-based login for testing.  Additionally, you\nmust then grant the \nermrest\n role to the \nhatrac\n role in PostgreSQL\nso that Hatrac can look up client authentication information at\nruntime.\n\n\nExample Apache configuration\n\n\nSee the sample \nwsgi_hatrac.conf\n file in the git repo, which would be\ninstalled under \n/etc/httpd/conf.d/\n on Red Hat flavored machines:\n\n\nAllowEncodedSlashes On\n\nWSGIPythonOptimize 1\nWSGIDaemonProcess hatrac processes=4 threads=4 user=hatrac maximum-requests=2000\nWSGIScriptAlias /hatrac /usr/lib/python2.7/site-packages/hatrac/hatrac.wsgi\nWSGIPassAuthorization On\n\nWSGISocketPrefix /var/run/wsgi/wsgi\n\n\nLocation /hatrac\n\n\n   AuthType webauthn\n   Require webauthn-optional\n\n   WSGIProcessGroup hatrac\n\n\n/Location\n\n\n\n\nWorking with SE-Linux\n\n\nThe following is an example set of commands to allow Hatrac to write\nto the filesystem in a Fedora installation.  On other distributions,\nthe appropriate path and SE-Linux contexts might vary slightly:\n\n\nsetsebool -P httpd_can_network_connect_db on\nsemanage fcontext --add --type httpd_sys_rw_content_t \"/var/www/hatrac(/.*)?\"\nrestorecon -rv /var/www/hatrac\nsemanage fcontext --add --type httpd_sys_content_t \"/home/hatrac(/.*)?\"\nrestorecon -rv /home/hatrac\n\n\n\nErrors regarding WSGI socket\n\n\nOn some versions of Fedora and CentOS, you may encounter errors in the\nApache SSL server log similar to \nUnable to connect to WSGI daemon\nprocess on '/var/run/wsgi/wsgi.1331.1.1.sock'\n.\n\n\nA workaround is to configure the SE-Linux context:\n\n\nsemanage fcontext --add --type httpd_var_run_t \"/var/run/wsgi\"\nrestorecon -rv /var/run/wsgi", 
            "title": "Installing on Red Hat-derived Linux"
        }, 
        {
            "location": "/INSTALL/#hatrac-installation", 
            "text": "Hatrac  (pronounced\n\"hat rack\") is a simple object storage service for web-based,\ndata-oriented collaboration.", 
            "title": "Hatrac Installation"
        }, 
        {
            "location": "/INSTALL/#install-code", 
            "text": "Check out the development code from GitHub.  Install prerequisites:  Apache HTTPD  PostgreSQL  Python  web.py  webauthn2  Install hatrac Python package from top-level of development code.  python setup.py install  Run  basic tests  or continue to  configure the web stack .", 
            "title": "Install code"
        }, 
        {
            "location": "/INSTALL/#basic-testing", 
            "text": "You can perform some local testing of Hatrac without configuring the\nwhole web service stack, daemon account, nor daemon account configuration data:  # make sure Hatrac is installed\n% python setup.py install\n\n# get rid of any previous test data\n% dropdb hatrac_test\n% rm -rf hatrac_test_data\n\n# create empty test database\n% createdb hatrac_test\n\n# run tests\n% python test/smoketest.py  The test script should run to completion without printing anything. If\nit encounters errors, diagnostics will be printed and the script will\nexit.  You MUST start with an empty test database and empty test data\ndirectory prior to each run of the test.", 
            "title": "Basic testing"
        }, 
        {
            "location": "/INSTALL/#configure-web-stack", 
            "text": "These steps continue following the basic code installation . For installations using SE-Linux,\nplease see  working with SE-Linux  below.   Create  hatrac  daemon account.  E.g.  useradd --create-home --system hatrac  (as root)  Create  hatrac  PostgreSQL role.  E.g.  createuser -d hatrac  (as PostgreSQL superuser)  Configure  ~hatrac/hatrac_config.json  See  example Hatrac configuration  below.  Create and initialize  hatrac  database.  E.g.  createdb hatrac  (as  hatrac  user)  E.g.  hatrac-deploy your_username_or_group  (as  hatrac  user)  Create file storage directory under Apache  E.g.  mkdir /var/www/hatrac   chown hatrac /var/www/hatrac  (as root)  Configure  ~hatrac/webauthn2_config.json  See  example Webauthn2 configuration  below.  Configure  mod_wsgi  to run Hatrac  See  example Apache configuration  below.   The  hatrac-deploy  step above depends on having a proper ~hatrac/hatrac_config.json  file already populated and an empty\ndatabase already created. It simply initializes the database schema.  If working in a SELinux environment see section below to SELinux specific additional steps needed before running the tests", 
            "title": "Configure web stack"
        }, 
        {
            "location": "/INSTALL/#example-hatrac-configuration", 
            "text": "This configuration works on a Fedora and Ubuntu host for a filesystem deployment:  {\n    \"storage_backend\": \"filesystem\",\n    \"storage_path\": \"/var/www/hatrac\",\n    \"database_type\": \"postgres\",\n    \"database_dsn\": \"dbname=hatrac\",\n    \"database_schema\": \"hatrac\",\n    \"database_max_retries\": 5,\n    \"403_html\": \" html body h1 Access Forbidden /h1 p %(message)s /p /body /html \",\n    \"401_html\": \" html body h1 Authentication Required /h1 p %(message)s /p /body /html \"\n}  This configuration works for an Amazon AWS S3 deployment:  {\n    \"backend\": \"amazons3\",\n    \"s3_bucket\" :  S3_BUCKET_NAME ,\n    \"s3_connection\": {\n    \"aws_access_key_id\" :  AWS_ACCESS_KEY_ID ,\n        \"aws_secret_access_key\":  AWS_SECRET_ACCESS_KEY \n    },\n    \"database_type\": \"postgres\",\n    \"database_dsb\": \"dbname=hatrac\",\n    \"database_schema\": \"hatrac\",\n    \"database_max_retries\": 5\n}", 
            "title": "Example Hatrac configuration"
        }, 
        {
            "location": "/INSTALL/#rest-api-testing", 
            "text": "You can perform system testing of the whole web service stack, if\nconfigured with cookie-based authentication (such as using a companion\nERMrest installation as described in the subsequent configration\nexamples of this document):  # manually create a session cookie\n% curl -b cookie -c cookie \\\n   -d username=testuser -d password=testpassword \\\n   https://$(hostname)/ermrest/auth/session\n\n# run the test script\n% COOKIES=cookie bash test/rest-smoketest.sh", 
            "title": "REST API testing"
        }, 
        {
            "location": "/INSTALL/#example-webauthn2-configuration", 
            "text": "This configuration allows Hatrac to share an existing Webauthn2\ndeployment from an ERMrest installation (if ERMrest is configured with\nthe same cookie name and path settings):  {\n      \"require_client\": true,\n      \"require_attributes\": true, \n      \"listusers_permit\": [\"admin\"], \n      \"listattributes_permit\": [\"admin\"], \n      \"manageusers_permit\": [\"admin\"], \n      \"manageattributes_permit\": [\"admin\"],\n\n      \"session_expiration_minutes\": 30, \n      \"def_passwd_len\": 10, \n      \"hash_passwd_reps\": 1000,\n\n      \"sessionids_provider\": \"webcookie\", \n      \"sessionstates_provider\": \"database\", \n      \"clients_provider\": \"database\", \n      \"attributes_provider\": \"database\",\n\n      \"handler_uri_usersession\": \"/ermrest/authn/session\",\n\n      \"web_cookie_name\": \"ermrest\", \n      \"web_cookie_path\": \"/\", \n      \"web_cookie_secure\": true, \n      \"setheader\": false,\n\n      \"database_schema\": \"webauthn2\", \n      \"database_type\": \"postgres\", \n      \"database_dsn\": \"dbname=ermrest\", \n      \"database_max_retries\": 5\n}  You will also have to grant ermrest permissions to the hatrac role:\nGRANT ermrest TO hatrac ; (as postgres user)  Note : at present, Hatrac does not expose any Webauthn2 REST APIs\nso you MUST share an existing deployment as above if you want to use a\nlocal account and session-based login for testing.  Additionally, you\nmust then grant the  ermrest  role to the  hatrac  role in PostgreSQL\nso that Hatrac can look up client authentication information at\nruntime.", 
            "title": "Example Webauthn2 configuration"
        }, 
        {
            "location": "/INSTALL/#example-apache-configuration", 
            "text": "See the sample  wsgi_hatrac.conf  file in the git repo, which would be\ninstalled under  /etc/httpd/conf.d/  on Red Hat flavored machines:  AllowEncodedSlashes On\n\nWSGIPythonOptimize 1\nWSGIDaemonProcess hatrac processes=4 threads=4 user=hatrac maximum-requests=2000\nWSGIScriptAlias /hatrac /usr/lib/python2.7/site-packages/hatrac/hatrac.wsgi\nWSGIPassAuthorization On\n\nWSGISocketPrefix /var/run/wsgi/wsgi Location /hatrac \n\n   AuthType webauthn\n   Require webauthn-optional\n\n   WSGIProcessGroup hatrac /Location", 
            "title": "Example Apache configuration"
        }, 
        {
            "location": "/INSTALL/#working-with-se-linux", 
            "text": "The following is an example set of commands to allow Hatrac to write\nto the filesystem in a Fedora installation.  On other distributions,\nthe appropriate path and SE-Linux contexts might vary slightly:  setsebool -P httpd_can_network_connect_db on\nsemanage fcontext --add --type httpd_sys_rw_content_t \"/var/www/hatrac(/.*)?\"\nrestorecon -rv /var/www/hatrac\nsemanage fcontext --add --type httpd_sys_content_t \"/home/hatrac(/.*)?\"\nrestorecon -rv /home/hatrac", 
            "title": "Working with SE-Linux"
        }, 
        {
            "location": "/INSTALL/#errors-regarding-wsgi-socket", 
            "text": "On some versions of Fedora and CentOS, you may encounter errors in the\nApache SSL server log similar to  Unable to connect to WSGI daemon\nprocess on '/var/run/wsgi/wsgi.1331.1.1.sock' .  A workaround is to configure the SE-Linux context:  semanage fcontext --add --type httpd_var_run_t \"/var/run/wsgi\"\nrestorecon -rv /var/run/wsgi", 
            "title": "Errors regarding WSGI socket"
        }, 
        {
            "location": "/HOWTO/", 
            "text": "Hatrac How-to\n\n\nThis document assumes a basic familiarity with:\n\n\n\n\nHTTP protocol and web concepts\n\n\nObject storage concepts\n\n\nCommand-line environments and the \ncurl\n utility\n\n\n\n\nSee the \nREST API documentation\n for a complete overview\nof the supported resources and operations with detailed HTTP protocol\ninformation.\n\n\nBackground\n\n\nHatrac provides a client-controlled namespace hierarchy with\nclient-named objects containing arbitrary data content. In short, a\nHatrac namespace is similar to a directory in a traditional\nfilesystem, while a Hatrac object is similar to a file.\n\n\nHowever, a single Hatrac object name may have multiple content\nversions. Each version is given a unique, psuedo-random version\nidentifier when it is created. Any particular object version is\nimmutable and can only ever be seen with the same content that was\nprovided atomically when it was created. The bare object name\nimplicitly references the \nlatest\n available version, while\nversion-qualified names reference the particular version no matter\nwhat other updates are performed on the object.\n\n\nExamples\n\n\nIn the following examples, let's assume that Hatrac is deployed with a\nwebauthn2 configuration that uses local database\nproviders. Furthermore, assume that a test user \ntest-user-1\n is\ndefined and has been assigned an attribute \nmy-admin-group\n. For this\ndeployment, assume the hostname \nserver.example.org\n is hosting the\nservice stack.\n\n\nDeploying\n\n\nThis command initializes the deployment so that users with the\n\nmy-admin-group\n attribute are granted full privileges on the root\nnamespace:\n\n\nhatrac-deploy \"my-admin-group\"\n\n\n\nAuthentication using Database Providers\n\n\nHatrac currently depends on a sibling ERMrest deployment to have\naccess to its embedded webauthn2 security service for login. With the\nwebauthn2 \ndatabase\n providers, we can login via the command-line by\nsending an HTTP POST request with login form fields populated:\n\n\ncurl -b ~/cookie -c ~/cookie \\\n  -d username=test-user-1 \\\n  -d password=\"my secret\" \\\n  https://server.example.org/ermrest/authn/session\n\n\n\nThis command prints out the new session information as a JSON response\n(with modified whitespace here for readability):\n\n\n{\n  \"attributes\": [\n    {\"display_name\": \"my-admin-group\", \"id\": \"my-admin-group\"}, \n    {\"display_name\": \"test-user-1\", \"id\": \"test-user-1\"}\n  ], \n  \"seconds_remaining\": 1799, \n  \"since\": \"2016-05-06 23:38:15.798275+00:00\", \n  \"expires\": \"2016-05-07 00:08:15.798275+00:00\", \n  \"client\": {\"display_name\": \"test-user-1\", \"id\": \"test-user-1\"}\n}\n\n\n\nWith other security providers, more effort is required to obtain the\nequivalent \n~/cookie\n file needed for the rest of the examples below.\n\n\nListing the Root Namespace\n\n\nThe root namespace is listed with an HTTP GET on the namespace URL:\n\n\ncurl -b ~/cookie -c ~/cookie \\\n  https://server.example.org/hatrac/\n\n\n\nThe response represents the currently empty root namespace:\n\n\n[]\n\n\n\nCreating a Nested Namespace\n\n\nThe HTTP PUT operation with a special \nContent-Type\n header allows us\nto create a new namespace with our own chosen name:\n\n\ncurl -b ~/cookie -c ~/cookie \\\n  -H \"Content-Type: application/x-hatrac-namespace\" \\\n  -X PUT\n  https://server.example.org/hatrac/folder1\n\n\n\nThe response repeats the name we have chosen for the new namespace:\n\n\n/hatrac/folder1\n\n\n\nIf you repeat the namespace listing step for the root namespace, this\ntime the response will enumerate the single child namespace:\n\n\n[\"/hatrac/folder1\"]\n\n\n\nCreating an Object\n\n\nFirst, let's create a test data file:\n\n\ncat \n hello.txt \nEOF\n\n Line 1: Hello, World!\n\n Line 2: That's all, Folks!\nEOF\n\n\n\nNow, let's upload it using the built-in support for file upload via\nHTTP PUT using curl's \n-T\n transfer mode:\n\n\ncurl -b ~/cookie -c ~/cookie \\\n  -H \"Content-Type: text/plain\" \\\n  -T hello.txt \\\n  https://server.example.org/hatrac/folder1/object1\n\n\n\nThe response repeats the object name we have chosen but qualifies it\nwith a server-generated \nversion ID\n:\n\n\n/hatrac/folder1/object1:SP274AQOOO3TOXIS2BVSDA5HCE\n\n\n\nRetrieving an Object\n\n\nA simple HTTP GET will retrieve an existing object's \ncurrent version\n:\n\n\ncurl -b ~/cookie -c ~/cookie \\\n  https://server.example.org/hatrac/folder1/object1\n\n\n\nThe response contains the object content itself:\n\n\nLine 1: Hello, World!\nLine 2: That's all, Folks!\n\n\n\nRetrieving Object Metadata Too\n\n\nWe can also ask \ncurl\n to dump the protocol headers with the response\non standard output using the \n-D\n flag:\n\n\ncurl -b ~/cookie -c ~/cookie \\\n  -D - \\\n  https://server.example.org/hatrac/folder1/object1\n\n\n\nThe response contains the object content itself:\n\n\nHTTP/1.1 200 OK\nDate: Fri, 06 May 2016 23:55:28 GMT\nContent-Length: 49\nContent-Disposition: filename*=UTF-8''object1\nETag: \"SP274AQOOO3TOXIS2BVSDA5HCE\"\nVary: cookie\nContent-Type: text/plain; charset=UTF-8\n\nLine 1: Hello, World!\nLine 2: That's all, Folks!\n\n\n\nThe \nETag\n header is used to inform the HTTP client about cache\nvalidity. It happens to repeat the actual version ID but you SHOULD\nNOT rely on this in any client application. The Hatrac service MAY use\nother means for cache management in future revisions.\n\n\nUpdating an Object\n\n\nFirst, let's modify our existing data file:\n\n\ncat \n hello.txt \nEOF\n\n Line 3: Well, I spoke too soon...\n\n EOF\n\n\n\nNow, let's upload it the same as before. The server will automatically\ncreate a new version and update the \ncurrent version\n to point to this\nnew one:\n\n\ncurl -b ~/cookie -c ~/cookie \\\n  -H \"Content-Type: text/plain\" \\\n  -T hello.txt \\\n  https://server.example.org/hatrac/folder1/object1\n\n\n\nThe response repeats the object name we have chosen but qualifies it\nwith a server-generated \nversion ID\n:\n\n\n/hatrac/folder1/object1:3VJO6XIPAGVBAGPUIOMG546SWU\n\n\n\nIf you repeat the step to retrieve object and metadata, you will see\nthe new content:\n\n\nHTTP/1.1 200 OK\nDate: Sat, 07 May 2016 00:00:05 GMT\nContent-Length: 83\nContent-Disposition: filename*=UTF-8''object1\nETag: \"3VJO6XIPAGVBAGPUIOMG546SWU\"\nVary: cookie\nContent-Type: text/plain; charset=UTF-8\n\nLine 1: Hello, World!\nLine 2: That's all, Folks!\nLine 3: Well, I spoke too soon...\n\n\n\nRetrieving an Object Version\n\n\nSimply by using the full version-qualified URL for the object, you can\nretrieve the older version of the object:\n\n\ncurl -b ~/cookie -c ~/cookie \\\n  -D - \\\n  https://server.example.org/hatrac/folder1/object1:SP274AQOOO3TOXIS2BVSDA5HCE\n\n\n\nThe response will familiar:\n\n\nHTTP/1.1 200 OK\nDate: Sat, 07 May 2016 00:04:55 GMT\nContent-Length: 49\nContent-Disposition: filename*=UTF-8''object1\nETag: \"SP274AQOOO3TOXIS2BVSDA5HCE\"\nVary: cookie\nContent-Type: text/plain; charset=UTF-8\n\nLine 1: Hello, World!\nLine 2: That's all, Folks!\n\n\n\nDeleting an Object Version\n\n\nYou can delete a specific object version and it will no longer be\navailable for retrieval.  If you delete the \ncurrent version\n, the\nobject will automatically revert to the \nlatest\n remaining version as\nits new current version:\n\n\ncurl -b ~/cookie -c ~/cookie \\\n  -X DELETE \\\n  https://server.example.org/hatrac/folder1/object1:3VJO6XIPAGVBAGPUIOMG546SWU\n\n\n\nThis operation has no response content.  If you now retrieve the\nunqualified object name, you'll get the previous version again.\n\n\nDeleting an Object\n\n\nYou can delete the entire object and all of its versions at once:\n\n\ncurl -b ~/cookie -c ~/cookie \\\n  -X DELETE \\\n  https://server.example.org/hatrac/folder1/object1\n\n\n\nThis operation has no response content.  If you now retrieve the\nunqualified object name, you'll get a \n404 Not Found\n HTTP error.", 
            "title": "Other HOWTO information"
        }, 
        {
            "location": "/HOWTO/#hatrac-how-to", 
            "text": "This document assumes a basic familiarity with:   HTTP protocol and web concepts  Object storage concepts  Command-line environments and the  curl  utility   See the  REST API documentation  for a complete overview\nof the supported resources and operations with detailed HTTP protocol\ninformation.", 
            "title": "Hatrac How-to"
        }, 
        {
            "location": "/HOWTO/#background", 
            "text": "Hatrac provides a client-controlled namespace hierarchy with\nclient-named objects containing arbitrary data content. In short, a\nHatrac namespace is similar to a directory in a traditional\nfilesystem, while a Hatrac object is similar to a file.  However, a single Hatrac object name may have multiple content\nversions. Each version is given a unique, psuedo-random version\nidentifier when it is created. Any particular object version is\nimmutable and can only ever be seen with the same content that was\nprovided atomically when it was created. The bare object name\nimplicitly references the  latest  available version, while\nversion-qualified names reference the particular version no matter\nwhat other updates are performed on the object.", 
            "title": "Background"
        }, 
        {
            "location": "/HOWTO/#examples", 
            "text": "In the following examples, let's assume that Hatrac is deployed with a\nwebauthn2 configuration that uses local database\nproviders. Furthermore, assume that a test user  test-user-1  is\ndefined and has been assigned an attribute  my-admin-group . For this\ndeployment, assume the hostname  server.example.org  is hosting the\nservice stack.", 
            "title": "Examples"
        }, 
        {
            "location": "/HOWTO/#deploying", 
            "text": "This command initializes the deployment so that users with the my-admin-group  attribute are granted full privileges on the root\nnamespace:  hatrac-deploy \"my-admin-group\"", 
            "title": "Deploying"
        }, 
        {
            "location": "/HOWTO/#authentication-using-database-providers", 
            "text": "Hatrac currently depends on a sibling ERMrest deployment to have\naccess to its embedded webauthn2 security service for login. With the\nwebauthn2  database  providers, we can login via the command-line by\nsending an HTTP POST request with login form fields populated:  curl -b ~/cookie -c ~/cookie \\\n  -d username=test-user-1 \\\n  -d password=\"my secret\" \\\n  https://server.example.org/ermrest/authn/session  This command prints out the new session information as a JSON response\n(with modified whitespace here for readability):  {\n  \"attributes\": [\n    {\"display_name\": \"my-admin-group\", \"id\": \"my-admin-group\"}, \n    {\"display_name\": \"test-user-1\", \"id\": \"test-user-1\"}\n  ], \n  \"seconds_remaining\": 1799, \n  \"since\": \"2016-05-06 23:38:15.798275+00:00\", \n  \"expires\": \"2016-05-07 00:08:15.798275+00:00\", \n  \"client\": {\"display_name\": \"test-user-1\", \"id\": \"test-user-1\"}\n}  With other security providers, more effort is required to obtain the\nequivalent  ~/cookie  file needed for the rest of the examples below.", 
            "title": "Authentication using Database Providers"
        }, 
        {
            "location": "/HOWTO/#listing-the-root-namespace", 
            "text": "The root namespace is listed with an HTTP GET on the namespace URL:  curl -b ~/cookie -c ~/cookie \\\n  https://server.example.org/hatrac/  The response represents the currently empty root namespace:  []", 
            "title": "Listing the Root Namespace"
        }, 
        {
            "location": "/HOWTO/#creating-a-nested-namespace", 
            "text": "The HTTP PUT operation with a special  Content-Type  header allows us\nto create a new namespace with our own chosen name:  curl -b ~/cookie -c ~/cookie \\\n  -H \"Content-Type: application/x-hatrac-namespace\" \\\n  -X PUT\n  https://server.example.org/hatrac/folder1  The response repeats the name we have chosen for the new namespace:  /hatrac/folder1  If you repeat the namespace listing step for the root namespace, this\ntime the response will enumerate the single child namespace:  [\"/hatrac/folder1\"]", 
            "title": "Creating a Nested Namespace"
        }, 
        {
            "location": "/HOWTO/#creating-an-object", 
            "text": "First, let's create a test data file:  cat   hello.txt  EOF  Line 1: Hello, World!  Line 2: That's all, Folks!\nEOF  Now, let's upload it using the built-in support for file upload via\nHTTP PUT using curl's  -T  transfer mode:  curl -b ~/cookie -c ~/cookie \\\n  -H \"Content-Type: text/plain\" \\\n  -T hello.txt \\\n  https://server.example.org/hatrac/folder1/object1  The response repeats the object name we have chosen but qualifies it\nwith a server-generated  version ID :  /hatrac/folder1/object1:SP274AQOOO3TOXIS2BVSDA5HCE", 
            "title": "Creating an Object"
        }, 
        {
            "location": "/HOWTO/#retrieving-an-object", 
            "text": "A simple HTTP GET will retrieve an existing object's  current version :  curl -b ~/cookie -c ~/cookie \\\n  https://server.example.org/hatrac/folder1/object1  The response contains the object content itself:  Line 1: Hello, World!\nLine 2: That's all, Folks!", 
            "title": "Retrieving an Object"
        }, 
        {
            "location": "/HOWTO/#retrieving-object-metadata-too", 
            "text": "We can also ask  curl  to dump the protocol headers with the response\non standard output using the  -D  flag:  curl -b ~/cookie -c ~/cookie \\\n  -D - \\\n  https://server.example.org/hatrac/folder1/object1  The response contains the object content itself:  HTTP/1.1 200 OK\nDate: Fri, 06 May 2016 23:55:28 GMT\nContent-Length: 49\nContent-Disposition: filename*=UTF-8''object1\nETag: \"SP274AQOOO3TOXIS2BVSDA5HCE\"\nVary: cookie\nContent-Type: text/plain; charset=UTF-8\n\nLine 1: Hello, World!\nLine 2: That's all, Folks!  The  ETag  header is used to inform the HTTP client about cache\nvalidity. It happens to repeat the actual version ID but you SHOULD\nNOT rely on this in any client application. The Hatrac service MAY use\nother means for cache management in future revisions.", 
            "title": "Retrieving Object Metadata Too"
        }, 
        {
            "location": "/HOWTO/#updating-an-object", 
            "text": "First, let's modify our existing data file:  cat   hello.txt  EOF  Line 3: Well, I spoke too soon...  EOF  Now, let's upload it the same as before. The server will automatically\ncreate a new version and update the  current version  to point to this\nnew one:  curl -b ~/cookie -c ~/cookie \\\n  -H \"Content-Type: text/plain\" \\\n  -T hello.txt \\\n  https://server.example.org/hatrac/folder1/object1  The response repeats the object name we have chosen but qualifies it\nwith a server-generated  version ID :  /hatrac/folder1/object1:3VJO6XIPAGVBAGPUIOMG546SWU  If you repeat the step to retrieve object and metadata, you will see\nthe new content:  HTTP/1.1 200 OK\nDate: Sat, 07 May 2016 00:00:05 GMT\nContent-Length: 83\nContent-Disposition: filename*=UTF-8''object1\nETag: \"3VJO6XIPAGVBAGPUIOMG546SWU\"\nVary: cookie\nContent-Type: text/plain; charset=UTF-8\n\nLine 1: Hello, World!\nLine 2: That's all, Folks!\nLine 3: Well, I spoke too soon...", 
            "title": "Updating an Object"
        }, 
        {
            "location": "/HOWTO/#retrieving-an-object-version", 
            "text": "Simply by using the full version-qualified URL for the object, you can\nretrieve the older version of the object:  curl -b ~/cookie -c ~/cookie \\\n  -D - \\\n  https://server.example.org/hatrac/folder1/object1:SP274AQOOO3TOXIS2BVSDA5HCE  The response will familiar:  HTTP/1.1 200 OK\nDate: Sat, 07 May 2016 00:04:55 GMT\nContent-Length: 49\nContent-Disposition: filename*=UTF-8''object1\nETag: \"SP274AQOOO3TOXIS2BVSDA5HCE\"\nVary: cookie\nContent-Type: text/plain; charset=UTF-8\n\nLine 1: Hello, World!\nLine 2: That's all, Folks!", 
            "title": "Retrieving an Object Version"
        }, 
        {
            "location": "/HOWTO/#deleting-an-object-version", 
            "text": "You can delete a specific object version and it will no longer be\navailable for retrieval.  If you delete the  current version , the\nobject will automatically revert to the  latest  remaining version as\nits new current version:  curl -b ~/cookie -c ~/cookie \\\n  -X DELETE \\\n  https://server.example.org/hatrac/folder1/object1:3VJO6XIPAGVBAGPUIOMG546SWU  This operation has no response content.  If you now retrieve the\nunqualified object name, you'll get the previous version again.", 
            "title": "Deleting an Object Version"
        }, 
        {
            "location": "/HOWTO/#deleting-an-object", 
            "text": "You can delete the entire object and all of its versions at once:  curl -b ~/cookie -c ~/cookie \\\n  -X DELETE \\\n  https://server.example.org/hatrac/folder1/object1  This operation has no response content.  If you now retrieve the\nunqualified object name, you'll get a  404 Not Found  HTTP error.", 
            "title": "Deleting an Object"
        }, 
        {
            "location": "/REST-API/", 
            "text": "Hatrac REST API\n\n\nHatrac\n (pronounced\n\"hat rack\") is a simple object storage service for web-based,\ndata-oriented collaboration. It presents a simple HTTP REST API with\nthe following characteristics:\n\n\nContents\n\n\nMain Topics\n\n\nThis documentation is broken down into the following general topics:\n\n\n\n\nURL Conventions\n\n\nResource Types Overview\n\n\nRoot Namespace\n\n\nNested Namespaces\n\n\nObjects\n\n\nObject Versions\n\n\nMetadata\n\n\nAccess Control Lists\n\n\nChunked Uploads\n\n\n\n\nQuick Links to Operations\n\n\nThe REST API supports the following operations.\n\n\n\n\nNamespace operations\n\n\nGet namespace listing\n\n\nCreate nested namespace\n\n\nDelete nested namespace\n\n\nObject operations\n\n\nCreate or update object\n\n\nGet object content\n\n\nDelete object\n\n\nObject version operations\n\n\nGet object version list\n\n\nCreate object version\n\n\nGet object version content\n\n\nDelete object version\n\n\nMetadata management operations\n\n\nGet metadata collection\n\n\nGet metadata value\n\n\nCreate or update metadata value\n\n\nDelete metadata value\n\n\nAccess control list operations\n\n\nGet access controls\n\n\nUpdate access control list\n\n\nClear access control list\n\n\nChunked upload operations\n\n\nGet upload job listing\n\n\nCreate upload job\n\n\nGet upload job status\n\n\nUpload data chunk\n\n\nFinalize upload job\n\n\nCancel upload job\n\n\n\n\nURL Conventions\n\n\nAny Hatrac URL is a valid HTTP URL and contains user-generated content\nwhich may need to be escaped. Several reserved characters from RFC\n3986 are used as meta-syntax in Hatrac and MUST be escaped if they are\nmeant to be part of a user-generated name value and MUST NOT be\nescaped if they are meant to indicate the Hatrac meta-syntax:\n- The '/' or forward-slash, used as a path separator character\n- The ':' or colon, used to separate object names from version IDs\n- The ';' or semi-colon, used to separate resource names and sub-resource keywords\n\n\nAll other reserved characters should be escaped in user-generated\ncontent in URLs, but have no special meaning to Hatrac when appearing\nin unescaped form.\n\n\nResource Naming and Lifecycle Rules\n\n\nThe hierarchical Hatrac naming model defines three main types of resource:\n\n\n\n\nNamespace\n\n\nObject\n\n\nObject Version\n\n\n\n\nThe model supports a hierarchy of nested namespaces while objects and\ntheir versions appear only at the leaves of the tree. A particular\nhierarchical name has a three-phase lifecycle that can oscillate in\nthe latter two phases:\n\n\n\n\nUndefined, until the name is bound\n\n\nDefined, from the moment the name is bound until deleted\n\n\nNamespaces: a name bound as a namespace will always be a namespace\n    if available to access.\n\n\nObjects: a name bound as an object will always be an object if\n    available to access.  \n\n\nDeleted, from the moment the name is deleted until restored to its\n   previous definition.\n\n\n\n\nAn implementation MAY permit \nrestoration\n of a deleted namespace or\nobject, but it is not required to do so. An implementation MUST\nprevent other reuse of names.  The definition of restoration is that\nall of the following hold:\n- The name is defined as the same type of resource that was previous\n  defined prior to deleted;\n- At the moment of restoration, the parent namespace encoded in the\n  name is still a defined namespace;\n- When an object name is restored, the constraints on object version\n  naming continue to hold as if the object had never been deleted;\n- When a namespace is restored, any child namespace or object MAY be\n  restored and MAY remain deleted. Any child restoration MUST follow\n  the same restoration rules, recursively.\n\n\nObject Version Naming\n\n\nA particular object name can be qualified with a version identifier\nhaving a three-phase lifecycle that can oscillate on the latter two\nphases:\n\n\n\n\nUndefined, until the version identifier is issued to a content\nvalue\n\n\nDefined, from the moment a version is created until the version is\ndeleted\n\n\nUnavailable, from the moment a version is deleted until it is\nrestored with the same content value\n\n\n\n\nHatrac allows object versions to be deleted in order to reclaim\nbacking storage resources, as an alternative to simply making versions\nunavailable by restricting their access control settings.\n\n\nReferential Stability\n\n\nA particular namespace or object name denotes the same abstract\ncontainer from the point of definition into the indefinite future, but\nthat container can change.  Namespaces can gain or lose children\n(nested namespaces and objects) and objects can gain or lose object\nversions.\n\n\nA particular object version reference (name plus version identifier)\nis a permanent, immutable reference to a specific content value. Such\na referenced content value MAY become unavailable if the object\nversion is deleted or its access control rules are\nrestrictive. However, when and if it becomes available, it MUST always\ndenote the same content value for all clients able to access it at any\npoint in time. To guarantee this stability for clients while giving\nsome freedom to implementers, the following rules are defined for\nversion identifiers:\n\n\n\n\nVersion identifiers are opaque, local qualifiers for a specific\n  object name. An implementation MAY use globally distinct version\n  identifiers but clients SHOULD NOT compare version identifiers\n  associated with different object names.\n\n\nAny two distinct content values applied as updates to the same\n  object MUST be issued distinct version identifiers.  Hence, any two\n  reference URLs with identical object name and version identifier\n  MUST denote the same content value.\n\n\nAny two updates applied to the same object with identical content\n  value are subject to more complex rules depending on the sequencing\n  of operations:\n\n\nIf the first update yields an object version which is deleted\n  prior to the second update operation\n\n\nThe implementation MAY reuse the same version identifier used\n  for the previously deleted object version which denoted the same\n  content value.\n\n\nThe implementation MAY issue a distinct version identifier for\n  each object version that has non-overlapping lifetimes while\n  denoting the same content value.\n\n\n\n\n\n\nIf the first update yields an object version which is still\n  defined prior to the second update operation\n\n\nThe second operation MAY fail with a conflict if the\n  implementation does not support storage and tracking of\n  duplicate content values\n\n\nThe second operation MAY issue a new, distinct version\n  identifier\n\n\n\n\n\n\nSimultaneous update must be logically resolved as if one of the\n     updates occurred before the other, satisfying the preceding\n     rules.\n\n\n\n\nThese rules allow a broad range of implementation techniques while\npreventing collaboration hazards such as unstable references denoting\ndifferent data values at different times or data value collisions\ncausing ambiguous object ownership and privileges.\n\n\nRoot Namespace Resource\n\n\nThe root of a Hatrac deployment is an HTTPS URL of the form:\n\n\n\n\nhttps:// \nauthority\n / \nprefix\n \n\n\n\n\nWhere \nauthority\n is a DNS hostname and optional port number, and\n\nprefix\n is a '/' separated string of any length.  A deployment MAY\nuse a fixed path to route HTTP requests to Hatrac alongside other\nservices in the same authority (host and port), or it MAY use an empty\nprefix if the entire HTTP namespace of the authority is dedicated to\nHatrac resources.\n\n\nIn all documentation below, the \"/ \nprefix\n\" is considered to be part\nof the \nparent path\n URL path elements.  Therefore every example URL\nwill be a hierarchical name starting with a \"/\" character.\n\n\nNamespace Listing Retrieval\n\n\nThe GET operation is used to list direct children of a namespace:\n\n\nGET /parent_path/namespace_id\nHost: authority_name\nIf-None-Match: etag_value\n\n\n\nfor which a successful response is a JSON array of child resource\nURLs:\n\n\n200 OK\nContent-Type: application/json\nContent-Length: N\nETag: etag_value\n\n[\"/hatrac/parent_path/namespace_id/child1\", ...]\n\n\n\nIf the \ntext/uri-list\n content-type is negotiated, the response will\nbe a whitespace separated list of child URLs:\n\n\n200 OK\nContent-Type: text/uri-list\nContent-Length: N\nETag: etag_value\n\n/hatrac/parent_path/namespace_id/child1\n/hatrac/parent_path/namespace_id/child2\n...\n\n\n\nNamespace Listing Metadata Retrieval\n\n\nThe HEAD operation is used to get basic status information:\n\n\nHEAD /parent_path/namespace_id\nHost: authority_name\n\n\n\nfor which a successful response is:\n\n\n200 OK\nContent-Type: application/json\nContent-Length: N\n\n\n\nindicating that an \nN\n byte JSON representation is available.  This\noperation is essentially equivalent to the GET operation but with the\nactual child listing elided.\n\n\nDeletion of Root Namespace Forbidden\n\n\nThe root namespace of a Hatrac deployment SHOULD forbid delete\noperations. It is nonsensical to have a Hatrac deployment without a\nroot namespace.\n\n\nNested Namespace Resources\n\n\nAny hierarchical namespace in Hatrac has an HTTPS URL of the form:\n\n\n\n\nhttps:// \nauthority\n / \nparent path\n / \nnamespace id\n\n\n\n\nWhere \nparent path\n is the name of the enclosing namespace and\n\nnamespace id\n is the relative name of the nested namespace. Of\ncourse, the enclosing namespace may be the root namespace of the\ndeployment, e.g. \n/hatrac\n, or another nested namespace,\ne.g. \n/hatrac/some/ancestors\n.\n\n\nNested Namespace Creation\n\n\nThe PUT operation is used to create a new nested namespace:\n\n\nPUT /parent_path/namespace_id\nHost: authority_name\nContent-Type: application/x-hatrac-namespace\n\n\n\nwhich may also be modified with the \nparents\n query parameter:\n\n\nPUT /parent_path/namespace_id?parents=true\nHost: authority_name\nContent-Type: application/x-hatrac-namespace\n\n\n\nto request automatic creation of missing ancestors in \nparent path\n.\nIn either case, a successful response is:\n\n\n201 Created\nLocation: /parent_path/namespace_id\nContent-Type: text/uri-list\nContent-Length: N\n\n/parent_path/namespace_id\n\n\n\nNote\n: see related object resource interface for pragmatic\ndiscussion of the use of Content-Type to disambiguate namespace and\nobject creation requests.\n\n\nTypical PUT error responses would be:\n- \n401 Unauthorized\n: the client is not authenticated and\n  anonymous creation of such a namespace is not supported.\n- \n403 Forbidden\n: the client is authenticated but does not have\n  sufficient privilege to create or update the namespace.\n- \n404 Not Found\n: the parent namespace does not exist and\n  \nparents=true\n query parameter was not supplied to request automatic\n  creation of missing ancestors.\n- \n409 Conflict\n: the namespace cannot be created due to a\n  conflict with existing state of the service:\n  - The \nparent path\n does not denote a namespace\n  - The namespace already exists\n\n\nNested Namespace Listing Retrieval\n\n\nThe same GET and HEAD operations documented above for the Root\nNamespace Resource can also list direct children of any nested\nnamespace.\n\n\nFor nested namespaces, typical GET or HEAD error responses would be:\n- \n404 Not Found\n: the name does not map to an available resource on\n  the server.\n\n\nNote\n: since nested namespaces and objects share the same\nhierarchical name structure, a GET operation on a name might resolve\nto an object rather a namespace. As such, error responses applicable\nto an object might be encountered as well.\n\n\nNested Namespace Deletion\n\n\nThe DELETE operation is used to delete a nested namespace\n\n\nDELETE /parent_path/namespace_id\nHost: authority_name\n\n\n\nfor which a successful response is:\n\n\n204 No Content\n\n\n\nAn implementation SHOULD NOT allow deletion of non-empty\nnamespaces. It is RECOMMENDED that deletion of non-empty namespaces be\nrejected, but an implementation MAY treat it as a bulk request by the\nsame client to delete everything contained in the namespace prior to\ndeleting the namespace itself.  It is further RECOMMENDED that such a\ndeletion be processed atomically, considering all client privileges in\nadvance, but an implementation MAY partially delete contents before\nfailing due to an authorization error on some subset of contents.\n\n\nTypical DELETE error responses would be:\n- \n401 Unauthorized\n: the client is not authenticated and\n  anonymous deletion of such a resource is not supported.\n- \n403 Forbidden\n: the client is authenticated but does not have\n  sufficient privilege to delete the resource.\n- \n404 Not Found\n: the name does not denote an existing resource.\n- \n409 Conflict\n: the resource cannot be deleted at this time,\n    i.e. because the namespace is not empty.\n\n\nObject Resources\n\n\nAny unversioned object name in Hatrac has an HTTPS URL of the form:\n\n\n\n\nhttps:// \nauthority\n / \nnamespace path\n / \nobject name\n\n\n\n\nWhere \nnamespace path\n is the name of the enclosing namespace and\n\nobject name\n is the relative name of the object.\n\n\nObject Creation and Update\n\n\nThe PUT operation is used to create a new object or a new version of\nan existing object.  Literal object content is provided as input:\n\n\nPUT /namespace_path/object_name\nHost: authority_name\nContent-Type: text/plain\nContent-Length: 14\nContent-MD5: ZXS/CYPMeEBJpBYNGYhyjA==\nContent-SHA256: 5+aEMqzlEZxe9xPaDUZ0GyBvTUaZf4s0yMpPgV/0yt0=\nContent-Disposition: filename*=UTF-8''test.txt\nIf-Match: etag_value\nIf-None-Match: *\n\n...content...\n\n\n\nThis example has metadata consistent with an object containing a\nsingle Unix-style text line \n...content...\\n\n inclusive of the\nline-terminator.\n\n\nAs with nested namespace creation, an optional query parameter may be\nincluded to enable automatic namespace creation:\n\n\nPUT /namespace_path/object_name?parents=true\n...\n\n\n\nThe optional \nIf-Match\n and \nIf-None-Match\n headers MAY be specified\nto limit object update to specific scenarios. In a normal situation,\nonly one of these two headers is specified in a single request:\n  - An \netag value\n with the \nIf-Match\n header requires that the current version of the object on the server match the version indicated by the \netag value\n in order for the object to be updated as per the request \ncontent\n.\n  - An \n*\n with the \nIf-None-Match\n header requires that the object lack a current version on the server in order for the object to be created or updated as per the request \ncontent\n.\n\n\nWithout either \nIf-Match\n or \nIf-None-Match\n headers in the request,\nthe update will be unconditionally applied if allowed by policy and\nthe current state of the server. When supplied, they select HTTP\nstandard conditional request processing.\n\n\nThe optional \nContent-MD5\n and \nContent-SHA256\n headers can carry an\nMD5 or SHA-256 \nhash value\n, respectively. The \nhash value\n SHOULD be\nthe base64 encoded representation of the underlying bit sequence\ndefined by the relevant hash algorithm standard. Either or both, if\nsupplied, will be stored and returned with data retrieval responses,\nuseful for end-to-end data integrity checks by clients. An\nimplementation MAY checksum the supplied \ncontent\n and reject the\nrequest if it mismatches any supplied \nhash value\n or if any \nhash\nvalue\n is malformed. An implementation MAY recognize and accept\nhex-encoded \nhash value\n or MAY reject it as a bad request, but in\neither case it MUST always return proper base64-encoded \nhash value\n\nin any service-issued \nContent-MD5\n or \nContent-SHA256\n response\nheader.\n\n\nThe optional \nContent-Disposition\n header will be stored and returned\nwith data retrieval responses. An implementation MAY restrict which\nvalues are acceptable as content disposition instructions. Every\nimplementation SHOULD support the \nfilename*=UTF-8''\n \nfilename\n\nsyntax where \nfilename\n is a basename with no path separator\ncharacters. According to the web standards, the \nfilename\n component\nembedded in this header MUST be UTF-8 which is then URL-escaped\n(percent-encoded) on an octet by octet basis, just like URL components\nin this REST API.\n\n\nA successful response is:\n\n\n201 Created\nLocation: /namespace_path/object_name:version_id\nContent-Type: text/uri-list\nContent-Length: N\n\n/namespace_path/object_name:version_id\n\n\n\nThe successful response includes the \nversion id\n qualified name of\nthe newly updated object.\n\n\nTypical PUT error responses would be:\n  - \n400 Bad Request\n: the client supplied a \nContent-MD5\n header\n      with a \nhash value\n that does not match the entity \ncontent\n\n      which was recieved.\n  - \n401 Unauthorized\n: the client is not authenticated and\n      anonymous creation of such an object is not supported.\n  - \n403 Forbidden\n: the client is authenticated but does not have\n      sufficient privilege to create the object.\n  - \n404 Not Found\n: the \nparent path\n does not exist and the\n    \nparents=true\n query parameter was not supplied to request\n    automatic creation of missing ancestors.\n  - \n409 Conflict\n: the object cannot be created due to a\n      conflict with existing state of the service:\n    - The \nnamespace path\n may not denote a namespace\n    - The \nobject name\n may already be in use as a namespace,\n      therefore preventing its use as an object.\n  - \n412 Precondition Failed\n: the object cannot be created or updated due to its current state on the server not meeting the requirements indicated by the \nIf-Match\n and/or \nIf-None-Match\n request headers.\n\n\nNote\n: There is ambiguity in the meaning of a URL when creating a\nnew object or nested namespace because they have the same syntactic\nstructure.  Hatrac disambiguates such requests in a decision process:\n\n\n\n\nIf the full path denotes an existing object, the PUT request MUST\n   denote a request to update the content of the existing object,\n   regardless of what \nContent-Type\n is present.\n\n\nIf \nContent-Type\n is \napplication/x-hatrac-namespace\n, the PUT\n   request MUST denote a request to create a new nested namespace.\n\n\nAny other PUT request not matching the above is considered an\n   object creation request.\n\n\n\n\nThis set of rules makes it simple to create any common object or\nnamespace. In the degenerate case where one wishes to create an object\nwith content that looks exactly like a namespace request input, the\nsolution is to first create an empty object (e.g. with \nContent-Type:\ntext/plan\n) and then immediately update its content with the desired\ncontent.\n\n\nObject Retrieval\n\n\nThe GET operation is used to retrieve the current version of an object:\n\n\nGET /namespace_path/object_name\nHost: authority_name\nAccept: *\nIf-None-Match: etag_value\n\n\n\nThe optional \nIf-None-Match\n header MAY supply an \nETag\n value\nobtained from a previous retrieval operation, to inform the server\nthat the client already has a copy of a particular version of the\nobject.\n\n\nfor which a successful response is:\n\n\n200 OK\nContent-Type: content_type\nContent-Length: N\nContent-MD5: hash_value\nContent-SHA256: hash_value\nContent-Disposition: filename*=UTF-8''filename\nContent-Location: /namespace_path/object_name:version\nETag: etag_value\n\n...content...\n\n\n\nThe optional \nContent-MD5\n, \nContent-SHA256\n, and\n\nContent-Disposition\n headers MUST be present if supplied during\nobject creation and MAY be present if the service computes missing\nvalues in other cases. The \nContent-Location\n header SHOULD be present and\nspecifies the URL for the version of the object which was retrieved.\n\n\nIt is RECOMMENDED that a Hatrac server return an \nETag\n indicating the version of the \ncontent\n returned to the client.\n\n\nTypical GET error responses would be:\n  - \n304 Not Modified\n: the \netag value\n supplied in the \nIf-None-Match\n header matches the current object version on the server.\n  - \n401 Unauthorized\n: the client is not authenticated and\n      anonymous retrieval of such an object is not supported.\n  - \n403 Forbidden\n: the client is authenticated but does not have\n      sufficient privilege to retrieve the object.\n  - \n404 Not Found\n: the name does not denote a defined object.\n  - \n409 Conflict\n: the object cannot be retrieved at this time,\n      e.g. there are currently no object versions defined.\n\n\nObject Metadata Retrieval\n\n\nThe HEAD operation is used to retrieve information about the current\nversion of an object:\n\n\nHEAD /namespace_path/object_name\nHost: authority_name\nAccept: *\n\n\n\nfor which a successful response is:\n\n\n200 OK\nContent-Type: content_type\nContent-Length: N\nContent-MD5: hash_value\nContent-SHA256: hash_value\nContent-Disposition: filename*=UTF-8''filename\nContent-Location: /namespace_path/object_name:version\n\n\n\nThe HEAD operation is essentially equivalent to the GET operation but\nwith the actual object content elided.\n\n\nObject Version List Retrieval\n\n\nThe GET operation is used to list versions of an object:\n\n\nGET /namespace_path/object_name;versions\nHost: authority_name\n\n\n\nfor which a successful response is a JSON array of version resource\nURLs:\n\n\n200 OK\nContent-Type: application/json\nContent-Length: N\n\n[\"/hatrac/namespace_path/object_name:version_id\", ...]\n\n\n\nIf the \ntext/uri-list\n content-type is negotiated, the response\nis a whitespace separated list of version URLs:\n\n\n200 OK\nContent-Type: text/uri-list\nContent-Length: N\n\n/hatrac/namespace_path/object_name:version1_id\n/hatrac/namespace_path/object_name:version2_id\n...\n\n\n\nObject Deletion\n\n\nThe DELETE operation is used to delete an object\n\n\nDELETE /namespace_path/object_name\nHost: authority_name\nIf-Match: etag_value\n\n\n\nThe optional \nIf-Match\n header MAY be specified to prevent object deletion unless the current object version on the server matches the version indicated by the \netag value\n.\n\n\nfor which a successful response is:\n\n\n204 No Content\n\n\n\nAn implementation SHOULD NOT allow deletion of objects with existing\nobject versions. It is RECOMMENDED that an implementation treat\ndeletion as a bulk request by the same client to delete all versions\nof the object prior to deleting the object itself, however an\nimplementation MAY signal an error when object versions exist.  It is\nfurther RECOMMENDED that such a deletion be processed atomically,\nconsidering all client privileges in advance, but an implementation\nMAY partially delete versions before failing due to an authorization\nerror on some subset of the versions.\n\n\nTypical DELETE error responses would be:\n- \n401 Unauthorized\n: the client is not authenticated and\n  anonymous deletion of such a resource is not supported.\n- \n403 Forbidden\n: the client is authenticated but does not have\n  sufficient privilege to delete the resource.\n- \n404 Not Found\n: the name does not denote an existing resource.\n- \n409 Conflict\n: the resource cannot be deleted at this time,\n    i.e. because object versions still exist.\n- \n412 Precondition Failed\n: the deletion was aborted because the current object version on the server does not match the version indicated by the \nIf-Match\n request header.\n\n\nObject Version Resources\n\n\nAny versioned object name in Hatrac has an HTTPS URL of the form:\n\n\n\n\nhttps:// \nauthority\n / \nnamespace path\n / \nobject name\n : \nversion id\n\n\n\n\nWhere \nversion id\n is the service-issued identifier for a particular\nversion of the named object.\n\n\nObject Version Creation\n\n\nSee the previous section on Object Creation and Update. Object\nversions are created by performing an update on the unversioned object\nURL.\n\n\nObject Version Retrieval\n\n\nA particular version of an object can be retrieved using the GET\noperation whether or not it is the current version of the object:\n\n\nGET /namespace_path/object_name:version_id\nHost: authority_name\nIf-None-Match: etag_value\n\n\n\nfor which the successful response is:\n\n\n200 OK\nContent-Type: content_type\nContent-MD5: hash_value\nContent-SHA256: hash_value\nContent-Disposition: filename*=UTF-8''filename\nContent-Length: N\nETag: etag_value\n\n...content...\n\n\n\nwith the same interpretation as documented for Object Retrieval above.\n\n\nThe \nETag\n and \nIf-None-Match\n headers allow client-side caching of object versions. Because a Hatrac object version is immutable, the \netag value\n for a given object version SHOULD NOT change over its lifetime.\n\n\nObject Version Metadata Retrieval\n\n\nMetadata for a particular version of an object can be retrieved using\nthe HEAD operation whether or not it is the current version of the\nobject:\n\n\nHEAD /namespace_path/object_name:version_id\nHost: authority_name\n\n\n\nfor which the successful response is:\n\n\n200 OK\nContent-Type: content_type\nContent-MD5: hash_value\nContent-SHA256: hash_value\nContent-Disposition: filename*=UTF-8''filename\nContent-Length: N\n\n\n\nwith the same interpretation as documented for Object Metadata\nRetrieval above.\n\n\nObject Version Deletion\n\n\nThe DELETE operation is used to delete an object version\n\n\nDELETE /namespace_path/object_name:version_id\nHost: authority_name\n\n\n\nfor which a successful response is:\n\n\n204 No Content\n\n\n\nFor completeness in the protocol, an \nIf-Match\n header MAY be specified to control deletion of object versions, but it is redundant since object versions are immutable and their content cannot be in a different state than observed on a previous access.\n\n\nTypical DELETE error responses would be:\n- \n401 Unauthorized\n: the client is not authenticated and\n  anonymous deletion of such a resource is not supported.\n- \n403 Forbidden\n: the client is authenticated but does not have\n  sufficient privilege to delete the resource.\n- \n404 Not Found\n: the name does not denote an existing resource.\n- \n412 Precondition Failed\n: the \nIf-Match\n request header was specified with an \netag value\n which does not match this object version.\n\n\nVersions of objects can be deleted whether or not they are the current\nversion:\n\n\n\n\nDeletion of any version MUST make that version unavailable.\n\n\nDeletion of any version MAY permanently discard content. An\n    implementation MAY retain deleted content to allow restoration\n    procedures not documented here.\n\n\nDeletion of the current version will cause the next most recent\n    version of the object to become its new current version.\n\n\nAn object may be left empty, i.e. with no current version, if all\n    versions have been deleted.  A subsequent update can reintroduce\n    content for the object.\n\n\n\n\nMetadata Sub-Resources\n\n\nThe service also exposes sub-resources for metadata management on\nexisting object versions:\n\n\n\n\nhttps:// \nauthority\n / \nresource name\n ;metadata\n\n\nhttps:// \nauthority\n / \nresource name\n ;metadata/ \nfieldname\n\n\n\n\nWhere \nresource name\n is currently restricted to object version names\nas described above. The \nfieldname\n is a lower-case string which\nmatches an HTTP request header suitable for describing content\nmetadata. The currently recognized \nfieldnames\n include:\n\n\n\n\ncontent-type\n\n\ncontent-disposition\n\n\ncontent-md5\n\n\ncontent-sha256\n\n\n\n\nLifecycle and Ownership\n\n\nMetadata are sub-resources of the main resource identified in the\n\nresource name\n in the URL, and their lifetime is bounded by the\nlifetime of that main resource.\n\n\n\n\nInitial metadata MAY be specified during object creation and update.\n\n\nImmutable checksums MAY be added on existing object versions.\n\n\nMutable metadata MAY be added, removed, or modified on existing object versions.\n\n\n\n\nMetadata Collection Retrieval\n\n\nThe GET operation is used to retrieve all metadata sub-resources en masse\nas a document:\n\n\nGET /resource_name;metadata\nHost: authority_name\nAccept: application/json\nIf-None-Match: etag_value\n\n\n\nfor which the successful response is:\n\n\n200 OK\nContent-Type: application/json\nContent-Length: N\nETag: etag_value\n\n{\"content-type\": content_type, \n \"content-md5\": hash_value,\n \"content-sha256\": hash_value,\n \"content-disposition\": disposition}\n\n\n\nThe standard\n\nobject version metadata retrieval\n,\noperation uses the \nHEAD\n method on the main resource to retrieve this\nsame metadata as HTTP response headers.\n\n\nMetadata Value Retrieval\n\n\nThe GET operation is used to retrieve one metadata sub-resource as a\ntext value:\n\n\nGET /resource_name;metadata/fieldname\nHost: authority_name\nAccept: text/plain\nIf-None-Match: etag_value\n\n\n\nfor which the successful response is:\n\n\n200 OK\nContent-Type: text/plain\nContent-Length: N\nETag: etag_value\n\nvalue\n\n\n\nThe textual \nvalue\n is identical to what would be present in the HTTP\nresponse header value when retrieving the main resource content.\n\n\nMetadata Value Creation and Update\n\n\nThe PUT operation is used to create or update one metadata sub-resource as a\ntext value:\n\n\nPUT /resource_name;metadata/fieldname\nHost: authority_name\nContent-Type: text/plain\nIf-Match: etag_value\n\nvalue\n\n\n\nfor which the successful response is:\n\n\n204 No Content\n\n\n\nThe textual \nvalue\n is identical to what would be present in the HTTP\nrequest header value when creating the main resource content.\n\n\nMetadata Value Deletion\n\n\nThe DELETE operation is used to create or update one metadata sub-resource as a\ntext value:\n\n\nDELETE /resource_name;metadata/fieldname\nHost: authority_name\n\n\n\nfor which the successful response is:\n\n\n204 No Content\n\n\n\nAccess Control List Sub-Resources\n\n\nAn access control policy sub-resource has an HTTPS URL of the form:\n\n\n\n\nhttps:// \nauthority\n / \nresource name\n ;acl\n\n\n(for a list of all ACLs on the resource)\n\n\nhttps:// \nauthority\n / \nresource name\n ;acl/ \naccess\n\n\n(for a specific ACL)\n\n\nhttps:// \nauthority\n / \nresource name\n ;acl/ \naccess\n / \nentry\n\n\n(for a specific ACL entry)\n\n\n\n\nWhere \nresource name\n is a namespace, object, or object version name\nas described above, \naccess\n is a specific access mode that is\napplicable to that type of resource, and \nentry\n is a specific \nrole\n\nname or the \n*\n wildcard.  The full set of access control lists for\neach resource type is:\n- Namespace\n  - \nowner\n: lists roles considered to be owners of the namespace.\n  - \ncreate\n: lists roles permitted to create new children in the namespace.\n  - \nsubtree-owner\n: lists roles considered to be owners of the namespace or any namespace, object, or object version beneath the namespace.\n  - \nsubtree-create\n: lists roles permitted to create new children of the namespace or of any namespace beneath the namespace.\n  - \nsubtree-update\n: lists roles permitted to update data on any object beneath the namespace.\n  - \nsubtree-read\n: lists roles permitted to read any object version beneath the namespace.\n- Object\n  - \nowner\n: lists roles considered to be owners of the object.\n  - \nupdate\n: lists roles permitted to update object with new versions.\n  - \nsubtree-owner\n: lists roles considered to be owners of any object version for the object.\n  - \nsubtree-read\n: lists roles permitted to read any object version for the object.\n- Object Version\n  - \nowner\n: lists roles considered to be owners of the object version.\n  - \nread\n: lists roles permitted to read the object version.\n\n\nLifecycle and Ownership\n\n\nAccess control lists are sub-resources of the main resource identified\nby the \nresource name\n in the URL, and they exist for the entire\nlifetime of the main resource.\n\n\n\n\nThe root namespace is configured out of band with initial ACL\n   content when a service is deployed.\n\n\nWhen a client creates a nested namespace or a new object, the\n   ownership of the new resource is set to the authenticated client by\n   default, but the client may specified an alternative owner list as\n   part of the creation request.  In the case of a new object, the\n   initial object version gets the same ACL settings as the newly\n   created object. \nTODO:\n define header to control initial ACLs\n   during PUT.\n\n\n\n\nAccess Control Retrieval\n\n\nThe GET operation is used to retrieve ACL settings en masse:\n\n\nGET /resource_name;acl\nHost: authority_name\nAccept: application/json\nIf-None-Match: etag_value\n\n\n\nfor which the successful response is:\n\n\n200 OK\nContent-Type: application/json\nContent-Length: N\nETag: etag_value\n\n{\"access\": [\"role\", ...], ...}\n\n\n\nwhere response contains a JSON object with one field per \naccess\n mode\nand an array of \nrole\n names and/or the \n*\n wildcard for each such access\nlist.\n\n\nThe HEAD operation can likewise retrieve en masse ACL metadata:\n\n\nHEAD /resource_name;acl\nHost: authority_name\nAccept: application/json\n\n\n\nfor which the successful response is:\n\n\n200 OK\nContent-Type: application/json\nContent-Length: N\n\n\n\nAccess Control List Retrieval\n\n\nThe GET operation is also used to retrieve a specific ACL:\n\n\nGET /resource_name;acl/access\nHost: authority_name\nAccept: application/json\nIf-None-Match: etag_value\n\n\n\nfor which the successful response is:\n\n\n200 OK\nContent-Type: application/json\nContent-Length: N\nETag: etag_value\n\n[\"role\",...]\n\n\n\nwhere the response contains just one array of \nrole\n names or the \n*\n\nwildcard.\n\n\nThe HEAD operation can likewise retrieve individual ACL metadata:\n\n\nHEAD /resource_name;acl/access\nHost: authority_name\nAccept: application/json\n\n\n\nfor which the successful response is:\n\n\n200 OK\nContent-Type: application/json\nContent-Length: N\n\n\n\nAccess Control List Entry Retrieval\n\n\nThe GET operation is also used to retrieve a specific ACL entry:\n\n\nGET /resource_name;acl/access/role\nHost: authority_name\nAccept: application/json\nIf-None-Match: etag_value\n\n\n\nfor which the successful response is:\n\n\n200 OK\nContent-Type: text/plain\nContent-Length: N\nETag: etag_value\n\nrole\n\n\n\nwhere the response contains just one \nrole\n name or \n*\n wildcard entry.\n\n\nThe HEAD operation is also used to retrieve metadata for a specific\nACL entry:\n\n\nHEAD /resource_name;acl/access/entry\nHost: authority_name\nAccept: application/json\n\n\n\nfor which the successful response is:\n\n\n200 OK\nContent-Type: text/plain\nContent-Length: N\n\n\n\nFor all of the ACL sub-resource retrieval operations, an \nIf-None-Match\n header MAY be specified with an \netag value\n to indicate that the client already possesses a copy of the sub-resource which was returned with an \nETag\n header containing that same \netag value\n. This is useful for cache control. The \netag value\n, if returned by the server, MUST indicate a specific configuration of the ACL sub-resource such that proper caching and precondition-protected updates are possible using the related HTTP protocol features.\n\n\nTypical GET error responses would be:\n  - \n401 Unauthorized\n: the client is not authenticated and\n      anonymous retrieval of such a policy is not supported.\n  - \n403 Forbidden\n: the client is authenticated but does not have\n      sufficient privilege to retrieve the policy.\n  - \n404 Not Found\n: the namespace or object resource or ACL\n      subresource is not found.\n  - \n304 Not Modified\n: the current state of the ACL sub-resource matches the \netag value\n specified in the \nIf-None-Match\n request header.\n\n\nAccess Control List Update\n\n\nThe PUT operation is used to rewrite a specific ACL:\n\n\nPUT /resource_name;acl/access\nHost: authority_name\nContent-Type: application/json\nIf-Match: etag_value\n\n[\"role\", ...]\n\n\n\nThe optional \nIf-Match\n header MAY be specified with the \netag value\n corresponding to the last retrieved ACL sub-resource configuration, in order to prevent update in the case that another client has simultaneously updated the same ACL sub-resource while this request was being prepared and submitted.\n\n\nThe successful response is:\n\n\n204 No Content\n\n\n\nwhere the input JSON array completely replaces the existing ACL.\n\n\nIt is RECOMMENDED that the implementation reject changes\nwhich would strip too many permissions, e.g. leaving a resource with\nno \nowner\n.\n\n\nThe PUT operation is also used to add one entry to a specific ACL:\n\n\nPUT /resource_name;acl/access/entry\nHost: authority_name\n\n\n\nfor which the successful response is:\n\n\n204 No Content\n\n\n\nwhere the \nentry\n role name or \n*\n wildcard is now present in the ACL.\n\n\nTypical PUT error responses would be:\n- \n400 Bad Request\n: the resource cannot be updates as requested,\n    i.e. because insufficient permissions would remain.\n- \n401 Unauthorized\n: the client is not authenticated and\n  anonymous update of such a resource is not supported.\n- \n403 Forbidden\n: the client is authenticated but does not have\n  sufficient privilege to update the resource.\n- \n404 Not Found\n: the name does not denote an existing resource.\n- \n412 Precondition Failed\n: the update was aborted because the ACL sub-resource state on the server did not match the \netag value\n present in an \nIf-Match\n request header.\n\n\nAccess Control List Deletion\n\n\nThe DELETE operation is used to clear a specific ACL:\n\n\nDELETE /resource_name;acl/access\nHost: authority_name\nIf-Match: etag_value\n\n\n\nThe optional \nIf-Match\n header MAY be specified with the \netag value\n corresponding to the last retrieved ACL sub-resource configuration, in order to prevent deletion in the case that anohter client has simultaneously updated the same ACL sub-resource while this request was being prepared and submitted.\n\n\nThe successful response is:\n\n\n204 No Content\n\n\n\nwhere the ACL is now empty.\n\n\nIt is RECOMMENDED that the implementation reject changes which would\nstrip too many permissions, e.g. leaving a resource with no \nowner\n.\n\n\nThe DELETE operation is also used to remove one entry from a specific ACL:\n\n\nGET /resource_name;acl/access/entry\nHost: authority_name\n\n\n\nfor which the successful response is:\n\n\n204 No Content\n\n\n\nwhere the \nentry\n role name or \n*\n wildcard is no longer present in\nthe ACL.\n\n\nTypical DELETE error responses would be:\n- \n400 Bad Request\n: the resource cannot be changed as requested,\n    i.e. because insufficient permissions would remain.\n- \n401 Unauthorized\n: the client is not authenticated and\n  anonymous update of such a resource is not supported.\n- \n403 Forbidden\n: the client is authenticated but does not have\n  sufficient privilege to update the resource.\n- \n404 Not Found\n: the name does not denote an existing resource.\n- \n412 Precondition Failed\n: the deletion was aborted because the ACL sub-resource state on the server did not match the \netag value\n present in an \nIf-Match\n request header.\n\n\nChunked Upload Resources\n\n\nTo efficiently support restartable transfer for very large object\ncontent, a stateful job management sub-resource exposes URLs for the\nform:\n\n\n\n\nhttps:// \nauthority\n / \nnamespace path\n / \nobject name\n ;upload\n\n\n(the set of upload jobs for a given object)\n\n\nhttps:// \nauthority\n / \nnamespace path\n / \nobject name\n ;upload / \njob id\n\n\n(a single upload job)\n\n\nhttps:// \nauthority\n / \nnamespace path\n / \nobject name\n ;upload / \njob id\n / \nchunk number\n\n\n(a single chunk of data)\n\n\n\n\nwhere \njob id\n is a service-issued identifier for one transfer job,\nand \nchunk number\n is a zero-based ordinal for the chunk within the\nseries of chunks where chunk number \nn\n starts at byte-offset \nn\n *\n\nK\n for a job using \nK\n byte chunk size.\n\n\nTo allow different implementations, the upload job processes a set of\nchunks of equal size determined at the time the job is\ncreated. Arbitrary byte offsets are \nnot\n allowed. The final chunk may\nbe less than the chunk size to account for arbitrary length jobs.\n\n\nThe three-phase chunked upload job has an effect equivalent to a\nsingle PUT request on an object:\n\n\n\n\nCreate service-side transfer job state\n\n\nSend set of idempotent chunks\n\n\nSignal job completion\n\n\n\n\nThe benefit of this technique is that individual HTTP requests can be\nkept to a reasonable size to prevent timeouts, and in the face of\ntransient communication failures the data transfer can easily resume\nin the middle.  Only chunks that were partially in flight need to be\nretransmitted.\n\n\nThis interface has been designed to accomodate two important\nimplementation strategies:\n- The fixed chunk size and ordinal position can be used to compute a\n  byte offset for direct assembly of data into sparse files in a\n  filesystem.  The chunks are non-overlapping byte ranges at fixed\n  offsets. Idempotent retransmission of chunks is permitted, but a\n  client SHOULD NOT send different content for multiple requests using\n  the same \nchunk number\n. An implementation MAY mix content of multiple\n  transmissions for the same \nchunk number\n.  An implementation MAY accept\n  completion of an upload job that has missing chunks.\n- The individual requests easily map to similar chunked upload\n  interfaced in object systems such as Amazon S3, allowing a thin\n  proxy to implement Hatrac on top of such services. Retransmission or\n  out-of-order transmission of chunks is permitted, but a client\n  SHOULD NOT skip any chunks. An implementation MAY reject\n  completion of an upload job that has missing chunks.\n\n\nHence, it is the client's responsibility to track acknowledged of\nindividual chunk transfers and defer completion of an upload job until\nall chunks have been successfully transmitted.\n\n\nChunked Upload Job Creation\n\n\nThe POST operation is used to create a new upload job:\n\n\nPOST /namespace_path/object_name;upload\nHost: authority_name\nContent-Type: application/json\n\n{\"chunk-length\": K, \n \"content-length\": N,\n \"content-type\": \"content_type\",\n \"content-md5\": \"hash_value\",\n \"content-sha256\": \"hash_value\",\n \"content-disposition\": \"disposition\"}\n\n\n\nwhere the JSON attributes \nchunk-length\n and \ncontent-length\n are\nmandatory to describe the shape of the data upload, while\n\ncontent-type\n, \ncontent-disposition\n, \ncontent-md5\n, and\n\ncontent-sha256\n are optional and provide additional metadata for the\ncompleted object, with the same semantics as if the object had been\ncreated as a simple object (without the upload job API) and those same\nfields had been provided as HTTP PUT request headers. For backwards\ncompatibility, these JSON attribute names are also supported as\naliases:\n\n\n\n\nchunk_bytes\n: deprecated alias for \nchunk-length\n\n\ntotal_bytes\n: deprecated alias for \ncontent-length\n\n\ncontent_md5\n: deprecated alias for \ncontent-md5\n\n\n\n\nAs with object and namespace creation, an optional query parameter may\nbe supplied to request automatic creation of ancestor namespaces:\n\n\nPOST /namespace_path/object_name;upload?parents=true\n...\n\n\n\nIn either case, the successful response is:\n\n\n201 Created\nLocation /namespace_path/object_name;upload/job_id\nContent-Type: text/uri-list\nContent-Length: N\n\n/namespace_path/object_name;upload/job_id\n\n\n\nwhere the new job is ready to receive data chunks.\n\n\nTypical PUT error responses would be:\n  - \n401 Unauthorized\n: the client is not authenticated and\n      anonymous creation of a job is not supported.\n  - \n403 Forbidden\n: the client is authenticated but does not have\n      sufficient privilege to create the job.\n  - \n409 Conflict\n: the object name is unavailable for such use.\n\n\nChunked Upload Job Listing Retrieval\n\n\nThe GET operation is used to list pending upload jobs on an object:\n\n\nGET /namespace_path/object_name;upload\nHost: authority_name\n\n\n\nwhere the successful response is a JSON array of job URLs:\n\n\n200 OK\nContent-Type: application/json\nContent-Length: N\n\n[\"/hatrac/namespace_path/object_name;upload/job_id\", ...]\n\n\n\nIf the \ntext/uri-list\n content-type is negotiated, the response will\nbe a whitespace separated list of job URLs:\n\n\n200 OK\nContent-Type: text/uri-list\nContent-Length: N\n\n/hatrac/namespace_path/object_name;upload/job_id1\n/hatrac/namespace_path/object_name;upload/job_id2\n...\n\n\n\nChunk Upload\n\n\nThe PUT operation is used to send data chunks for an existing job:\n\n\nPUT /namespace_path/object_name;upload/job_id/chunknumber\nHost: authority_name\nContent-Type: application/octet-stream\nContent-Length: K\n\n...data...\n\n\n\nfor which the successful response is:\n\n\n204 No Content\n\n\n\nwhere the data was received and stored.\n\n\nTypical PUT error responses would be:\n  - \n401 Unauthorized\n: the client is not authenticated and\n      anonymous upload of the chunk is not supported.\n  - \n403 Forbidden\n: the client is authenticated but does not have\n      sufficient privilege to upload the chunk.\n  - \n400 Bad Request\n: the chunk number is not a non-negative integer.\n  - \n409 Conflict\n: the chunk number is too large for the defined job.\n\n\nChunked Upload Job Finalization\n\n\nThe POST operation is used to signal completion of an upload job:\n\n\nPOST /namespace_path/object_name;upload/job_id\nHost: authority_name\n\n\n\nfor which the successful response is:\n\n\n201 Created\nLocation: /namespace_path/object_name:version_id\nContent-Type: text/uri-list\nContent-Length: N\n\n/namespace_path/object_name:version_id\n\n\n\nwhere \nLocation\n includes the URL of the newly created object version\nthat is comprised of all the uploaded data chunks as if it had been\ncreated by a corresponding PUT request:\n\n\nPUT /namespace_path/object_name\nHost: authority_name\nContent-Type: content_type\nContent-MD5: hash_value\nContent-Length: N\n\n...content...\n\n\n\nTypical POST error responses would be:\n  - \n401 Unauthorized\n the client is not authenticated\n  - \n403 Forbidden\n the client is authenticated but does not have\n    sufficient privilege to finalize the upload.\n  - \n409 Conflict\n the currently uploaded content does not match the\n    \nContent-MD5\n header of the original upload job. An implementation\n    MAY skip this validation but it is RECOMMENDED to perform this\n    validation rather than create broken objects.\n\n\nChunked Upload Job Status Retrieval\n\n\nThe GET operation is used to view the status of a pending upload:\n\n\nGET /namespace_path/object_name;upload/job_id\nHost: authority_name\n\n\n\nfor which the successful response is:\n\n\n200 OK\nContent-Type: application/json\nContent-Length: N\n\n{\"url\": \"/namespace_path/object_name;upload/job_id\",\n \"owner\": [\"role\"...],\n \"target\": \"/namespace_path/object_name\"\n \"chunk-length\": K,\n \"content-length\": N,\n ...\n}\n\n\n\nsummarizing the parameters set when the job was created including\noptional object metadata such as \ncontent-type\n. Note, there is no\nsupport for determining which chunks have or have not been uploaded as\nsuch tracking is not a requirement placed on Hatrac implementations.\n\n\nChunked Upload Job Cancellation\n\n\nThe DELETE method can be used to cancel an upload job that has not yet\nbeen finalized:\n\n\nDELETE /namespace_path/object_name;upload/job_id\nHost: authority_name\n\n\n\nfor which the successful response is:\n\n\n204 No Content\n\n\n\nOnce canceled, the job resource no longer exists and associated\nstorage SHOULD be reclaimed.", 
            "title": "Hatrac API and Service Semantics"
        }, 
        {
            "location": "/REST-API/#hatrac-rest-api", 
            "text": "Hatrac  (pronounced\n\"hat rack\") is a simple object storage service for web-based,\ndata-oriented collaboration. It presents a simple HTTP REST API with\nthe following characteristics:", 
            "title": "Hatrac REST API"
        }, 
        {
            "location": "/REST-API/#contents", 
            "text": "", 
            "title": "Contents"
        }, 
        {
            "location": "/REST-API/#main-topics", 
            "text": "This documentation is broken down into the following general topics:   URL Conventions  Resource Types Overview  Root Namespace  Nested Namespaces  Objects  Object Versions  Metadata  Access Control Lists  Chunked Uploads", 
            "title": "Main Topics"
        }, 
        {
            "location": "/REST-API/#quick-links-to-operations", 
            "text": "The REST API supports the following operations.   Namespace operations  Get namespace listing  Create nested namespace  Delete nested namespace  Object operations  Create or update object  Get object content  Delete object  Object version operations  Get object version list  Create object version  Get object version content  Delete object version  Metadata management operations  Get metadata collection  Get metadata value  Create or update metadata value  Delete metadata value  Access control list operations  Get access controls  Update access control list  Clear access control list  Chunked upload operations  Get upload job listing  Create upload job  Get upload job status  Upload data chunk  Finalize upload job  Cancel upload job", 
            "title": "Quick Links to Operations"
        }, 
        {
            "location": "/REST-API/#url-conventions", 
            "text": "Any Hatrac URL is a valid HTTP URL and contains user-generated content\nwhich may need to be escaped. Several reserved characters from RFC\n3986 are used as meta-syntax in Hatrac and MUST be escaped if they are\nmeant to be part of a user-generated name value and MUST NOT be\nescaped if they are meant to indicate the Hatrac meta-syntax:\n- The '/' or forward-slash, used as a path separator character\n- The ':' or colon, used to separate object names from version IDs\n- The ';' or semi-colon, used to separate resource names and sub-resource keywords  All other reserved characters should be escaped in user-generated\ncontent in URLs, but have no special meaning to Hatrac when appearing\nin unescaped form.", 
            "title": "URL Conventions"
        }, 
        {
            "location": "/REST-API/#resource-naming-and-lifecycle-rules", 
            "text": "The hierarchical Hatrac naming model defines three main types of resource:   Namespace  Object  Object Version   The model supports a hierarchy of nested namespaces while objects and\ntheir versions appear only at the leaves of the tree. A particular\nhierarchical name has a three-phase lifecycle that can oscillate in\nthe latter two phases:   Undefined, until the name is bound  Defined, from the moment the name is bound until deleted  Namespaces: a name bound as a namespace will always be a namespace\n    if available to access.  Objects: a name bound as an object will always be an object if\n    available to access.    Deleted, from the moment the name is deleted until restored to its\n   previous definition.   An implementation MAY permit  restoration  of a deleted namespace or\nobject, but it is not required to do so. An implementation MUST\nprevent other reuse of names.  The definition of restoration is that\nall of the following hold:\n- The name is defined as the same type of resource that was previous\n  defined prior to deleted;\n- At the moment of restoration, the parent namespace encoded in the\n  name is still a defined namespace;\n- When an object name is restored, the constraints on object version\n  naming continue to hold as if the object had never been deleted;\n- When a namespace is restored, any child namespace or object MAY be\n  restored and MAY remain deleted. Any child restoration MUST follow\n  the same restoration rules, recursively.", 
            "title": "Resource Naming and Lifecycle Rules"
        }, 
        {
            "location": "/REST-API/#object-version-naming", 
            "text": "A particular object name can be qualified with a version identifier\nhaving a three-phase lifecycle that can oscillate on the latter two\nphases:   Undefined, until the version identifier is issued to a content\nvalue  Defined, from the moment a version is created until the version is\ndeleted  Unavailable, from the moment a version is deleted until it is\nrestored with the same content value   Hatrac allows object versions to be deleted in order to reclaim\nbacking storage resources, as an alternative to simply making versions\nunavailable by restricting their access control settings.", 
            "title": "Object Version Naming"
        }, 
        {
            "location": "/REST-API/#referential-stability", 
            "text": "A particular namespace or object name denotes the same abstract\ncontainer from the point of definition into the indefinite future, but\nthat container can change.  Namespaces can gain or lose children\n(nested namespaces and objects) and objects can gain or lose object\nversions.  A particular object version reference (name plus version identifier)\nis a permanent, immutable reference to a specific content value. Such\na referenced content value MAY become unavailable if the object\nversion is deleted or its access control rules are\nrestrictive. However, when and if it becomes available, it MUST always\ndenote the same content value for all clients able to access it at any\npoint in time. To guarantee this stability for clients while giving\nsome freedom to implementers, the following rules are defined for\nversion identifiers:   Version identifiers are opaque, local qualifiers for a specific\n  object name. An implementation MAY use globally distinct version\n  identifiers but clients SHOULD NOT compare version identifiers\n  associated with different object names.  Any two distinct content values applied as updates to the same\n  object MUST be issued distinct version identifiers.  Hence, any two\n  reference URLs with identical object name and version identifier\n  MUST denote the same content value.  Any two updates applied to the same object with identical content\n  value are subject to more complex rules depending on the sequencing\n  of operations:  If the first update yields an object version which is deleted\n  prior to the second update operation  The implementation MAY reuse the same version identifier used\n  for the previously deleted object version which denoted the same\n  content value.  The implementation MAY issue a distinct version identifier for\n  each object version that has non-overlapping lifetimes while\n  denoting the same content value.    If the first update yields an object version which is still\n  defined prior to the second update operation  The second operation MAY fail with a conflict if the\n  implementation does not support storage and tracking of\n  duplicate content values  The second operation MAY issue a new, distinct version\n  identifier    Simultaneous update must be logically resolved as if one of the\n     updates occurred before the other, satisfying the preceding\n     rules.   These rules allow a broad range of implementation techniques while\npreventing collaboration hazards such as unstable references denoting\ndifferent data values at different times or data value collisions\ncausing ambiguous object ownership and privileges.", 
            "title": "Referential Stability"
        }, 
        {
            "location": "/REST-API/#root-namespace-resource", 
            "text": "The root of a Hatrac deployment is an HTTPS URL of the form:   https://  authority  /  prefix     Where  authority  is a DNS hostname and optional port number, and prefix  is a '/' separated string of any length.  A deployment MAY\nuse a fixed path to route HTTP requests to Hatrac alongside other\nservices in the same authority (host and port), or it MAY use an empty\nprefix if the entire HTTP namespace of the authority is dedicated to\nHatrac resources.  In all documentation below, the \"/  prefix \" is considered to be part\nof the  parent path  URL path elements.  Therefore every example URL\nwill be a hierarchical name starting with a \"/\" character.", 
            "title": "Root Namespace Resource"
        }, 
        {
            "location": "/REST-API/#namespace-listing-retrieval", 
            "text": "The GET operation is used to list direct children of a namespace:  GET /parent_path/namespace_id\nHost: authority_name\nIf-None-Match: etag_value  for which a successful response is a JSON array of child resource\nURLs:  200 OK\nContent-Type: application/json\nContent-Length: N\nETag: etag_value\n\n[\"/hatrac/parent_path/namespace_id/child1\", ...]  If the  text/uri-list  content-type is negotiated, the response will\nbe a whitespace separated list of child URLs:  200 OK\nContent-Type: text/uri-list\nContent-Length: N\nETag: etag_value\n\n/hatrac/parent_path/namespace_id/child1\n/hatrac/parent_path/namespace_id/child2\n...", 
            "title": "Namespace Listing Retrieval"
        }, 
        {
            "location": "/REST-API/#namespace-listing-metadata-retrieval", 
            "text": "The HEAD operation is used to get basic status information:  HEAD /parent_path/namespace_id\nHost: authority_name  for which a successful response is:  200 OK\nContent-Type: application/json\nContent-Length: N  indicating that an  N  byte JSON representation is available.  This\noperation is essentially equivalent to the GET operation but with the\nactual child listing elided.", 
            "title": "Namespace Listing Metadata Retrieval"
        }, 
        {
            "location": "/REST-API/#deletion-of-root-namespace-forbidden", 
            "text": "The root namespace of a Hatrac deployment SHOULD forbid delete\noperations. It is nonsensical to have a Hatrac deployment without a\nroot namespace.", 
            "title": "Deletion of Root Namespace Forbidden"
        }, 
        {
            "location": "/REST-API/#nested-namespace-resources", 
            "text": "Any hierarchical namespace in Hatrac has an HTTPS URL of the form:   https://  authority  /  parent path  /  namespace id   Where  parent path  is the name of the enclosing namespace and namespace id  is the relative name of the nested namespace. Of\ncourse, the enclosing namespace may be the root namespace of the\ndeployment, e.g.  /hatrac , or another nested namespace,\ne.g.  /hatrac/some/ancestors .", 
            "title": "Nested Namespace Resources"
        }, 
        {
            "location": "/REST-API/#nested-namespace-creation", 
            "text": "The PUT operation is used to create a new nested namespace:  PUT /parent_path/namespace_id\nHost: authority_name\nContent-Type: application/x-hatrac-namespace  which may also be modified with the  parents  query parameter:  PUT /parent_path/namespace_id?parents=true\nHost: authority_name\nContent-Type: application/x-hatrac-namespace  to request automatic creation of missing ancestors in  parent path .\nIn either case, a successful response is:  201 Created\nLocation: /parent_path/namespace_id\nContent-Type: text/uri-list\nContent-Length: N\n\n/parent_path/namespace_id  Note : see related object resource interface for pragmatic\ndiscussion of the use of Content-Type to disambiguate namespace and\nobject creation requests.  Typical PUT error responses would be:\n-  401 Unauthorized : the client is not authenticated and\n  anonymous creation of such a namespace is not supported.\n-  403 Forbidden : the client is authenticated but does not have\n  sufficient privilege to create or update the namespace.\n-  404 Not Found : the parent namespace does not exist and\n   parents=true  query parameter was not supplied to request automatic\n  creation of missing ancestors.\n-  409 Conflict : the namespace cannot be created due to a\n  conflict with existing state of the service:\n  - The  parent path  does not denote a namespace\n  - The namespace already exists", 
            "title": "Nested Namespace Creation"
        }, 
        {
            "location": "/REST-API/#nested-namespace-listing-retrieval", 
            "text": "The same GET and HEAD operations documented above for the Root\nNamespace Resource can also list direct children of any nested\nnamespace.  For nested namespaces, typical GET or HEAD error responses would be:\n-  404 Not Found : the name does not map to an available resource on\n  the server.  Note : since nested namespaces and objects share the same\nhierarchical name structure, a GET operation on a name might resolve\nto an object rather a namespace. As such, error responses applicable\nto an object might be encountered as well.", 
            "title": "Nested Namespace Listing Retrieval"
        }, 
        {
            "location": "/REST-API/#nested-namespace-deletion", 
            "text": "The DELETE operation is used to delete a nested namespace  DELETE /parent_path/namespace_id\nHost: authority_name  for which a successful response is:  204 No Content  An implementation SHOULD NOT allow deletion of non-empty\nnamespaces. It is RECOMMENDED that deletion of non-empty namespaces be\nrejected, but an implementation MAY treat it as a bulk request by the\nsame client to delete everything contained in the namespace prior to\ndeleting the namespace itself.  It is further RECOMMENDED that such a\ndeletion be processed atomically, considering all client privileges in\nadvance, but an implementation MAY partially delete contents before\nfailing due to an authorization error on some subset of contents.  Typical DELETE error responses would be:\n-  401 Unauthorized : the client is not authenticated and\n  anonymous deletion of such a resource is not supported.\n-  403 Forbidden : the client is authenticated but does not have\n  sufficient privilege to delete the resource.\n-  404 Not Found : the name does not denote an existing resource.\n-  409 Conflict : the resource cannot be deleted at this time,\n    i.e. because the namespace is not empty.", 
            "title": "Nested Namespace Deletion"
        }, 
        {
            "location": "/REST-API/#object-resources", 
            "text": "Any unversioned object name in Hatrac has an HTTPS URL of the form:   https://  authority  /  namespace path  /  object name   Where  namespace path  is the name of the enclosing namespace and object name  is the relative name of the object.", 
            "title": "Object Resources"
        }, 
        {
            "location": "/REST-API/#object-creation-and-update", 
            "text": "The PUT operation is used to create a new object or a new version of\nan existing object.  Literal object content is provided as input:  PUT /namespace_path/object_name\nHost: authority_name\nContent-Type: text/plain\nContent-Length: 14\nContent-MD5: ZXS/CYPMeEBJpBYNGYhyjA==\nContent-SHA256: 5+aEMqzlEZxe9xPaDUZ0GyBvTUaZf4s0yMpPgV/0yt0=\nContent-Disposition: filename*=UTF-8''test.txt\nIf-Match: etag_value\nIf-None-Match: *\n\n...content...  This example has metadata consistent with an object containing a\nsingle Unix-style text line  ...content...\\n  inclusive of the\nline-terminator.  As with nested namespace creation, an optional query parameter may be\nincluded to enable automatic namespace creation:  PUT /namespace_path/object_name?parents=true\n...  The optional  If-Match  and  If-None-Match  headers MAY be specified\nto limit object update to specific scenarios. In a normal situation,\nonly one of these two headers is specified in a single request:\n  - An  etag value  with the  If-Match  header requires that the current version of the object on the server match the version indicated by the  etag value  in order for the object to be updated as per the request  content .\n  - An  *  with the  If-None-Match  header requires that the object lack a current version on the server in order for the object to be created or updated as per the request  content .  Without either  If-Match  or  If-None-Match  headers in the request,\nthe update will be unconditionally applied if allowed by policy and\nthe current state of the server. When supplied, they select HTTP\nstandard conditional request processing.  The optional  Content-MD5  and  Content-SHA256  headers can carry an\nMD5 or SHA-256  hash value , respectively. The  hash value  SHOULD be\nthe base64 encoded representation of the underlying bit sequence\ndefined by the relevant hash algorithm standard. Either or both, if\nsupplied, will be stored and returned with data retrieval responses,\nuseful for end-to-end data integrity checks by clients. An\nimplementation MAY checksum the supplied  content  and reject the\nrequest if it mismatches any supplied  hash value  or if any  hash\nvalue  is malformed. An implementation MAY recognize and accept\nhex-encoded  hash value  or MAY reject it as a bad request, but in\neither case it MUST always return proper base64-encoded  hash value \nin any service-issued  Content-MD5  or  Content-SHA256  response\nheader.  The optional  Content-Disposition  header will be stored and returned\nwith data retrieval responses. An implementation MAY restrict which\nvalues are acceptable as content disposition instructions. Every\nimplementation SHOULD support the  filename*=UTF-8''   filename \nsyntax where  filename  is a basename with no path separator\ncharacters. According to the web standards, the  filename  component\nembedded in this header MUST be UTF-8 which is then URL-escaped\n(percent-encoded) on an octet by octet basis, just like URL components\nin this REST API.  A successful response is:  201 Created\nLocation: /namespace_path/object_name:version_id\nContent-Type: text/uri-list\nContent-Length: N\n\n/namespace_path/object_name:version_id  The successful response includes the  version id  qualified name of\nthe newly updated object.  Typical PUT error responses would be:\n  -  400 Bad Request : the client supplied a  Content-MD5  header\n      with a  hash value  that does not match the entity  content \n      which was recieved.\n  -  401 Unauthorized : the client is not authenticated and\n      anonymous creation of such an object is not supported.\n  -  403 Forbidden : the client is authenticated but does not have\n      sufficient privilege to create the object.\n  -  404 Not Found : the  parent path  does not exist and the\n     parents=true  query parameter was not supplied to request\n    automatic creation of missing ancestors.\n  -  409 Conflict : the object cannot be created due to a\n      conflict with existing state of the service:\n    - The  namespace path  may not denote a namespace\n    - The  object name  may already be in use as a namespace,\n      therefore preventing its use as an object.\n  -  412 Precondition Failed : the object cannot be created or updated due to its current state on the server not meeting the requirements indicated by the  If-Match  and/or  If-None-Match  request headers.  Note : There is ambiguity in the meaning of a URL when creating a\nnew object or nested namespace because they have the same syntactic\nstructure.  Hatrac disambiguates such requests in a decision process:   If the full path denotes an existing object, the PUT request MUST\n   denote a request to update the content of the existing object,\n   regardless of what  Content-Type  is present.  If  Content-Type  is  application/x-hatrac-namespace , the PUT\n   request MUST denote a request to create a new nested namespace.  Any other PUT request not matching the above is considered an\n   object creation request.   This set of rules makes it simple to create any common object or\nnamespace. In the degenerate case where one wishes to create an object\nwith content that looks exactly like a namespace request input, the\nsolution is to first create an empty object (e.g. with  Content-Type:\ntext/plan ) and then immediately update its content with the desired\ncontent.", 
            "title": "Object Creation and Update"
        }, 
        {
            "location": "/REST-API/#object-retrieval", 
            "text": "The GET operation is used to retrieve the current version of an object:  GET /namespace_path/object_name\nHost: authority_name\nAccept: *\nIf-None-Match: etag_value  The optional  If-None-Match  header MAY supply an  ETag  value\nobtained from a previous retrieval operation, to inform the server\nthat the client already has a copy of a particular version of the\nobject.  for which a successful response is:  200 OK\nContent-Type: content_type\nContent-Length: N\nContent-MD5: hash_value\nContent-SHA256: hash_value\nContent-Disposition: filename*=UTF-8''filename\nContent-Location: /namespace_path/object_name:version\nETag: etag_value\n\n...content...  The optional  Content-MD5 ,  Content-SHA256 , and Content-Disposition  headers MUST be present if supplied during\nobject creation and MAY be present if the service computes missing\nvalues in other cases. The  Content-Location  header SHOULD be present and\nspecifies the URL for the version of the object which was retrieved.  It is RECOMMENDED that a Hatrac server return an  ETag  indicating the version of the  content  returned to the client.  Typical GET error responses would be:\n  -  304 Not Modified : the  etag value  supplied in the  If-None-Match  header matches the current object version on the server.\n  -  401 Unauthorized : the client is not authenticated and\n      anonymous retrieval of such an object is not supported.\n  -  403 Forbidden : the client is authenticated but does not have\n      sufficient privilege to retrieve the object.\n  -  404 Not Found : the name does not denote a defined object.\n  -  409 Conflict : the object cannot be retrieved at this time,\n      e.g. there are currently no object versions defined.", 
            "title": "Object Retrieval"
        }, 
        {
            "location": "/REST-API/#object-metadata-retrieval", 
            "text": "The HEAD operation is used to retrieve information about the current\nversion of an object:  HEAD /namespace_path/object_name\nHost: authority_name\nAccept: *  for which a successful response is:  200 OK\nContent-Type: content_type\nContent-Length: N\nContent-MD5: hash_value\nContent-SHA256: hash_value\nContent-Disposition: filename*=UTF-8''filename\nContent-Location: /namespace_path/object_name:version  The HEAD operation is essentially equivalent to the GET operation but\nwith the actual object content elided.", 
            "title": "Object Metadata Retrieval"
        }, 
        {
            "location": "/REST-API/#object-version-list-retrieval", 
            "text": "The GET operation is used to list versions of an object:  GET /namespace_path/object_name;versions\nHost: authority_name  for which a successful response is a JSON array of version resource\nURLs:  200 OK\nContent-Type: application/json\nContent-Length: N\n\n[\"/hatrac/namespace_path/object_name:version_id\", ...]  If the  text/uri-list  content-type is negotiated, the response\nis a whitespace separated list of version URLs:  200 OK\nContent-Type: text/uri-list\nContent-Length: N\n\n/hatrac/namespace_path/object_name:version1_id\n/hatrac/namespace_path/object_name:version2_id\n...", 
            "title": "Object Version List Retrieval"
        }, 
        {
            "location": "/REST-API/#object-deletion", 
            "text": "The DELETE operation is used to delete an object  DELETE /namespace_path/object_name\nHost: authority_name\nIf-Match: etag_value  The optional  If-Match  header MAY be specified to prevent object deletion unless the current object version on the server matches the version indicated by the  etag value .  for which a successful response is:  204 No Content  An implementation SHOULD NOT allow deletion of objects with existing\nobject versions. It is RECOMMENDED that an implementation treat\ndeletion as a bulk request by the same client to delete all versions\nof the object prior to deleting the object itself, however an\nimplementation MAY signal an error when object versions exist.  It is\nfurther RECOMMENDED that such a deletion be processed atomically,\nconsidering all client privileges in advance, but an implementation\nMAY partially delete versions before failing due to an authorization\nerror on some subset of the versions.  Typical DELETE error responses would be:\n-  401 Unauthorized : the client is not authenticated and\n  anonymous deletion of such a resource is not supported.\n-  403 Forbidden : the client is authenticated but does not have\n  sufficient privilege to delete the resource.\n-  404 Not Found : the name does not denote an existing resource.\n-  409 Conflict : the resource cannot be deleted at this time,\n    i.e. because object versions still exist.\n-  412 Precondition Failed : the deletion was aborted because the current object version on the server does not match the version indicated by the  If-Match  request header.", 
            "title": "Object Deletion"
        }, 
        {
            "location": "/REST-API/#object-version-resources", 
            "text": "Any versioned object name in Hatrac has an HTTPS URL of the form:   https://  authority  /  namespace path  /  object name  :  version id   Where  version id  is the service-issued identifier for a particular\nversion of the named object.", 
            "title": "Object Version Resources"
        }, 
        {
            "location": "/REST-API/#object-version-creation", 
            "text": "See the previous section on Object Creation and Update. Object\nversions are created by performing an update on the unversioned object\nURL.", 
            "title": "Object Version Creation"
        }, 
        {
            "location": "/REST-API/#object-version-retrieval", 
            "text": "A particular version of an object can be retrieved using the GET\noperation whether or not it is the current version of the object:  GET /namespace_path/object_name:version_id\nHost: authority_name\nIf-None-Match: etag_value  for which the successful response is:  200 OK\nContent-Type: content_type\nContent-MD5: hash_value\nContent-SHA256: hash_value\nContent-Disposition: filename*=UTF-8''filename\nContent-Length: N\nETag: etag_value\n\n...content...  with the same interpretation as documented for Object Retrieval above.  The  ETag  and  If-None-Match  headers allow client-side caching of object versions. Because a Hatrac object version is immutable, the  etag value  for a given object version SHOULD NOT change over its lifetime.", 
            "title": "Object Version Retrieval"
        }, 
        {
            "location": "/REST-API/#object-version-metadata-retrieval", 
            "text": "Metadata for a particular version of an object can be retrieved using\nthe HEAD operation whether or not it is the current version of the\nobject:  HEAD /namespace_path/object_name:version_id\nHost: authority_name  for which the successful response is:  200 OK\nContent-Type: content_type\nContent-MD5: hash_value\nContent-SHA256: hash_value\nContent-Disposition: filename*=UTF-8''filename\nContent-Length: N  with the same interpretation as documented for Object Metadata\nRetrieval above.", 
            "title": "Object Version Metadata Retrieval"
        }, 
        {
            "location": "/REST-API/#object-version-deletion", 
            "text": "The DELETE operation is used to delete an object version  DELETE /namespace_path/object_name:version_id\nHost: authority_name  for which a successful response is:  204 No Content  For completeness in the protocol, an  If-Match  header MAY be specified to control deletion of object versions, but it is redundant since object versions are immutable and their content cannot be in a different state than observed on a previous access.  Typical DELETE error responses would be:\n-  401 Unauthorized : the client is not authenticated and\n  anonymous deletion of such a resource is not supported.\n-  403 Forbidden : the client is authenticated but does not have\n  sufficient privilege to delete the resource.\n-  404 Not Found : the name does not denote an existing resource.\n-  412 Precondition Failed : the  If-Match  request header was specified with an  etag value  which does not match this object version.  Versions of objects can be deleted whether or not they are the current\nversion:   Deletion of any version MUST make that version unavailable.  Deletion of any version MAY permanently discard content. An\n    implementation MAY retain deleted content to allow restoration\n    procedures not documented here.  Deletion of the current version will cause the next most recent\n    version of the object to become its new current version.  An object may be left empty, i.e. with no current version, if all\n    versions have been deleted.  A subsequent update can reintroduce\n    content for the object.", 
            "title": "Object Version Deletion"
        }, 
        {
            "location": "/REST-API/#metadata-sub-resources", 
            "text": "The service also exposes sub-resources for metadata management on\nexisting object versions:   https://  authority  /  resource name  ;metadata  https://  authority  /  resource name  ;metadata/  fieldname   Where  resource name  is currently restricted to object version names\nas described above. The  fieldname  is a lower-case string which\nmatches an HTTP request header suitable for describing content\nmetadata. The currently recognized  fieldnames  include:   content-type  content-disposition  content-md5  content-sha256", 
            "title": "Metadata Sub-Resources"
        }, 
        {
            "location": "/REST-API/#lifecycle-and-ownership", 
            "text": "Metadata are sub-resources of the main resource identified in the resource name  in the URL, and their lifetime is bounded by the\nlifetime of that main resource.   Initial metadata MAY be specified during object creation and update.  Immutable checksums MAY be added on existing object versions.  Mutable metadata MAY be added, removed, or modified on existing object versions.", 
            "title": "Lifecycle and Ownership"
        }, 
        {
            "location": "/REST-API/#metadata-collection-retrieval", 
            "text": "The GET operation is used to retrieve all metadata sub-resources en masse\nas a document:  GET /resource_name;metadata\nHost: authority_name\nAccept: application/json\nIf-None-Match: etag_value  for which the successful response is:  200 OK\nContent-Type: application/json\nContent-Length: N\nETag: etag_value\n\n{\"content-type\": content_type, \n \"content-md5\": hash_value,\n \"content-sha256\": hash_value,\n \"content-disposition\": disposition}  The standard object version metadata retrieval ,\noperation uses the  HEAD  method on the main resource to retrieve this\nsame metadata as HTTP response headers.", 
            "title": "Metadata Collection Retrieval"
        }, 
        {
            "location": "/REST-API/#metadata-value-retrieval", 
            "text": "The GET operation is used to retrieve one metadata sub-resource as a\ntext value:  GET /resource_name;metadata/fieldname\nHost: authority_name\nAccept: text/plain\nIf-None-Match: etag_value  for which the successful response is:  200 OK\nContent-Type: text/plain\nContent-Length: N\nETag: etag_value\n\nvalue  The textual  value  is identical to what would be present in the HTTP\nresponse header value when retrieving the main resource content.", 
            "title": "Metadata Value Retrieval"
        }, 
        {
            "location": "/REST-API/#metadata-value-creation-and-update", 
            "text": "The PUT operation is used to create or update one metadata sub-resource as a\ntext value:  PUT /resource_name;metadata/fieldname\nHost: authority_name\nContent-Type: text/plain\nIf-Match: etag_value\n\nvalue  for which the successful response is:  204 No Content  The textual  value  is identical to what would be present in the HTTP\nrequest header value when creating the main resource content.", 
            "title": "Metadata Value Creation and Update"
        }, 
        {
            "location": "/REST-API/#metadata-value-deletion", 
            "text": "The DELETE operation is used to create or update one metadata sub-resource as a\ntext value:  DELETE /resource_name;metadata/fieldname\nHost: authority_name  for which the successful response is:  204 No Content", 
            "title": "Metadata Value Deletion"
        }, 
        {
            "location": "/REST-API/#access-control-list-sub-resources", 
            "text": "An access control policy sub-resource has an HTTPS URL of the form:   https://  authority  /  resource name  ;acl  (for a list of all ACLs on the resource)  https://  authority  /  resource name  ;acl/  access  (for a specific ACL)  https://  authority  /  resource name  ;acl/  access  /  entry  (for a specific ACL entry)   Where  resource name  is a namespace, object, or object version name\nas described above,  access  is a specific access mode that is\napplicable to that type of resource, and  entry  is a specific  role \nname or the  *  wildcard.  The full set of access control lists for\neach resource type is:\n- Namespace\n  -  owner : lists roles considered to be owners of the namespace.\n  -  create : lists roles permitted to create new children in the namespace.\n  -  subtree-owner : lists roles considered to be owners of the namespace or any namespace, object, or object version beneath the namespace.\n  -  subtree-create : lists roles permitted to create new children of the namespace or of any namespace beneath the namespace.\n  -  subtree-update : lists roles permitted to update data on any object beneath the namespace.\n  -  subtree-read : lists roles permitted to read any object version beneath the namespace.\n- Object\n  -  owner : lists roles considered to be owners of the object.\n  -  update : lists roles permitted to update object with new versions.\n  -  subtree-owner : lists roles considered to be owners of any object version for the object.\n  -  subtree-read : lists roles permitted to read any object version for the object.\n- Object Version\n  -  owner : lists roles considered to be owners of the object version.\n  -  read : lists roles permitted to read the object version.", 
            "title": "Access Control List Sub-Resources"
        }, 
        {
            "location": "/REST-API/#lifecycle-and-ownership_1", 
            "text": "Access control lists are sub-resources of the main resource identified\nby the  resource name  in the URL, and they exist for the entire\nlifetime of the main resource.   The root namespace is configured out of band with initial ACL\n   content when a service is deployed.  When a client creates a nested namespace or a new object, the\n   ownership of the new resource is set to the authenticated client by\n   default, but the client may specified an alternative owner list as\n   part of the creation request.  In the case of a new object, the\n   initial object version gets the same ACL settings as the newly\n   created object.  TODO:  define header to control initial ACLs\n   during PUT.", 
            "title": "Lifecycle and Ownership"
        }, 
        {
            "location": "/REST-API/#access-control-retrieval", 
            "text": "The GET operation is used to retrieve ACL settings en masse:  GET /resource_name;acl\nHost: authority_name\nAccept: application/json\nIf-None-Match: etag_value  for which the successful response is:  200 OK\nContent-Type: application/json\nContent-Length: N\nETag: etag_value\n\n{\"access\": [\"role\", ...], ...}  where response contains a JSON object with one field per  access  mode\nand an array of  role  names and/or the  *  wildcard for each such access\nlist.  The HEAD operation can likewise retrieve en masse ACL metadata:  HEAD /resource_name;acl\nHost: authority_name\nAccept: application/json  for which the successful response is:  200 OK\nContent-Type: application/json\nContent-Length: N", 
            "title": "Access Control Retrieval"
        }, 
        {
            "location": "/REST-API/#access-control-list-retrieval", 
            "text": "The GET operation is also used to retrieve a specific ACL:  GET /resource_name;acl/access\nHost: authority_name\nAccept: application/json\nIf-None-Match: etag_value  for which the successful response is:  200 OK\nContent-Type: application/json\nContent-Length: N\nETag: etag_value\n\n[\"role\",...]  where the response contains just one array of  role  names or the  * \nwildcard.  The HEAD operation can likewise retrieve individual ACL metadata:  HEAD /resource_name;acl/access\nHost: authority_name\nAccept: application/json  for which the successful response is:  200 OK\nContent-Type: application/json\nContent-Length: N", 
            "title": "Access Control List Retrieval"
        }, 
        {
            "location": "/REST-API/#access-control-list-entry-retrieval", 
            "text": "The GET operation is also used to retrieve a specific ACL entry:  GET /resource_name;acl/access/role\nHost: authority_name\nAccept: application/json\nIf-None-Match: etag_value  for which the successful response is:  200 OK\nContent-Type: text/plain\nContent-Length: N\nETag: etag_value\n\nrole  where the response contains just one  role  name or  *  wildcard entry.  The HEAD operation is also used to retrieve metadata for a specific\nACL entry:  HEAD /resource_name;acl/access/entry\nHost: authority_name\nAccept: application/json  for which the successful response is:  200 OK\nContent-Type: text/plain\nContent-Length: N  For all of the ACL sub-resource retrieval operations, an  If-None-Match  header MAY be specified with an  etag value  to indicate that the client already possesses a copy of the sub-resource which was returned with an  ETag  header containing that same  etag value . This is useful for cache control. The  etag value , if returned by the server, MUST indicate a specific configuration of the ACL sub-resource such that proper caching and precondition-protected updates are possible using the related HTTP protocol features.  Typical GET error responses would be:\n  -  401 Unauthorized : the client is not authenticated and\n      anonymous retrieval of such a policy is not supported.\n  -  403 Forbidden : the client is authenticated but does not have\n      sufficient privilege to retrieve the policy.\n  -  404 Not Found : the namespace or object resource or ACL\n      subresource is not found.\n  -  304 Not Modified : the current state of the ACL sub-resource matches the  etag value  specified in the  If-None-Match  request header.", 
            "title": "Access Control List Entry Retrieval"
        }, 
        {
            "location": "/REST-API/#access-control-list-update", 
            "text": "The PUT operation is used to rewrite a specific ACL:  PUT /resource_name;acl/access\nHost: authority_name\nContent-Type: application/json\nIf-Match: etag_value\n\n[\"role\", ...]  The optional  If-Match  header MAY be specified with the  etag value  corresponding to the last retrieved ACL sub-resource configuration, in order to prevent update in the case that another client has simultaneously updated the same ACL sub-resource while this request was being prepared and submitted.  The successful response is:  204 No Content  where the input JSON array completely replaces the existing ACL.  It is RECOMMENDED that the implementation reject changes\nwhich would strip too many permissions, e.g. leaving a resource with\nno  owner .  The PUT operation is also used to add one entry to a specific ACL:  PUT /resource_name;acl/access/entry\nHost: authority_name  for which the successful response is:  204 No Content  where the  entry  role name or  *  wildcard is now present in the ACL.  Typical PUT error responses would be:\n-  400 Bad Request : the resource cannot be updates as requested,\n    i.e. because insufficient permissions would remain.\n-  401 Unauthorized : the client is not authenticated and\n  anonymous update of such a resource is not supported.\n-  403 Forbidden : the client is authenticated but does not have\n  sufficient privilege to update the resource.\n-  404 Not Found : the name does not denote an existing resource.\n-  412 Precondition Failed : the update was aborted because the ACL sub-resource state on the server did not match the  etag value  present in an  If-Match  request header.", 
            "title": "Access Control List Update"
        }, 
        {
            "location": "/REST-API/#access-control-list-deletion", 
            "text": "The DELETE operation is used to clear a specific ACL:  DELETE /resource_name;acl/access\nHost: authority_name\nIf-Match: etag_value  The optional  If-Match  header MAY be specified with the  etag value  corresponding to the last retrieved ACL sub-resource configuration, in order to prevent deletion in the case that anohter client has simultaneously updated the same ACL sub-resource while this request was being prepared and submitted.  The successful response is:  204 No Content  where the ACL is now empty.  It is RECOMMENDED that the implementation reject changes which would\nstrip too many permissions, e.g. leaving a resource with no  owner .  The DELETE operation is also used to remove one entry from a specific ACL:  GET /resource_name;acl/access/entry\nHost: authority_name  for which the successful response is:  204 No Content  where the  entry  role name or  *  wildcard is no longer present in\nthe ACL.  Typical DELETE error responses would be:\n-  400 Bad Request : the resource cannot be changed as requested,\n    i.e. because insufficient permissions would remain.\n-  401 Unauthorized : the client is not authenticated and\n  anonymous update of such a resource is not supported.\n-  403 Forbidden : the client is authenticated but does not have\n  sufficient privilege to update the resource.\n-  404 Not Found : the name does not denote an existing resource.\n-  412 Precondition Failed : the deletion was aborted because the ACL sub-resource state on the server did not match the  etag value  present in an  If-Match  request header.", 
            "title": "Access Control List Deletion"
        }, 
        {
            "location": "/REST-API/#chunked-upload-resources", 
            "text": "To efficiently support restartable transfer for very large object\ncontent, a stateful job management sub-resource exposes URLs for the\nform:   https://  authority  /  namespace path  /  object name  ;upload  (the set of upload jobs for a given object)  https://  authority  /  namespace path  /  object name  ;upload /  job id  (a single upload job)  https://  authority  /  namespace path  /  object name  ;upload /  job id  /  chunk number  (a single chunk of data)   where  job id  is a service-issued identifier for one transfer job,\nand  chunk number  is a zero-based ordinal for the chunk within the\nseries of chunks where chunk number  n  starts at byte-offset  n  * K  for a job using  K  byte chunk size.  To allow different implementations, the upload job processes a set of\nchunks of equal size determined at the time the job is\ncreated. Arbitrary byte offsets are  not  allowed. The final chunk may\nbe less than the chunk size to account for arbitrary length jobs.  The three-phase chunked upload job has an effect equivalent to a\nsingle PUT request on an object:   Create service-side transfer job state  Send set of idempotent chunks  Signal job completion   The benefit of this technique is that individual HTTP requests can be\nkept to a reasonable size to prevent timeouts, and in the face of\ntransient communication failures the data transfer can easily resume\nin the middle.  Only chunks that were partially in flight need to be\nretransmitted.  This interface has been designed to accomodate two important\nimplementation strategies:\n- The fixed chunk size and ordinal position can be used to compute a\n  byte offset for direct assembly of data into sparse files in a\n  filesystem.  The chunks are non-overlapping byte ranges at fixed\n  offsets. Idempotent retransmission of chunks is permitted, but a\n  client SHOULD NOT send different content for multiple requests using\n  the same  chunk number . An implementation MAY mix content of multiple\n  transmissions for the same  chunk number .  An implementation MAY accept\n  completion of an upload job that has missing chunks.\n- The individual requests easily map to similar chunked upload\n  interfaced in object systems such as Amazon S3, allowing a thin\n  proxy to implement Hatrac on top of such services. Retransmission or\n  out-of-order transmission of chunks is permitted, but a client\n  SHOULD NOT skip any chunks. An implementation MAY reject\n  completion of an upload job that has missing chunks.  Hence, it is the client's responsibility to track acknowledged of\nindividual chunk transfers and defer completion of an upload job until\nall chunks have been successfully transmitted.", 
            "title": "Chunked Upload Resources"
        }, 
        {
            "location": "/REST-API/#chunked-upload-job-creation", 
            "text": "The POST operation is used to create a new upload job:  POST /namespace_path/object_name;upload\nHost: authority_name\nContent-Type: application/json\n\n{\"chunk-length\": K, \n \"content-length\": N,\n \"content-type\": \"content_type\",\n \"content-md5\": \"hash_value\",\n \"content-sha256\": \"hash_value\",\n \"content-disposition\": \"disposition\"}  where the JSON attributes  chunk-length  and  content-length  are\nmandatory to describe the shape of the data upload, while content-type ,  content-disposition ,  content-md5 , and content-sha256  are optional and provide additional metadata for the\ncompleted object, with the same semantics as if the object had been\ncreated as a simple object (without the upload job API) and those same\nfields had been provided as HTTP PUT request headers. For backwards\ncompatibility, these JSON attribute names are also supported as\naliases:   chunk_bytes : deprecated alias for  chunk-length  total_bytes : deprecated alias for  content-length  content_md5 : deprecated alias for  content-md5   As with object and namespace creation, an optional query parameter may\nbe supplied to request automatic creation of ancestor namespaces:  POST /namespace_path/object_name;upload?parents=true\n...  In either case, the successful response is:  201 Created\nLocation /namespace_path/object_name;upload/job_id\nContent-Type: text/uri-list\nContent-Length: N\n\n/namespace_path/object_name;upload/job_id  where the new job is ready to receive data chunks.  Typical PUT error responses would be:\n  -  401 Unauthorized : the client is not authenticated and\n      anonymous creation of a job is not supported.\n  -  403 Forbidden : the client is authenticated but does not have\n      sufficient privilege to create the job.\n  -  409 Conflict : the object name is unavailable for such use.", 
            "title": "Chunked Upload Job Creation"
        }, 
        {
            "location": "/REST-API/#chunked-upload-job-listing-retrieval", 
            "text": "The GET operation is used to list pending upload jobs on an object:  GET /namespace_path/object_name;upload\nHost: authority_name  where the successful response is a JSON array of job URLs:  200 OK\nContent-Type: application/json\nContent-Length: N\n\n[\"/hatrac/namespace_path/object_name;upload/job_id\", ...]  If the  text/uri-list  content-type is negotiated, the response will\nbe a whitespace separated list of job URLs:  200 OK\nContent-Type: text/uri-list\nContent-Length: N\n\n/hatrac/namespace_path/object_name;upload/job_id1\n/hatrac/namespace_path/object_name;upload/job_id2\n...", 
            "title": "Chunked Upload Job Listing Retrieval"
        }, 
        {
            "location": "/REST-API/#chunk-upload", 
            "text": "The PUT operation is used to send data chunks for an existing job:  PUT /namespace_path/object_name;upload/job_id/chunknumber\nHost: authority_name\nContent-Type: application/octet-stream\nContent-Length: K\n\n...data...  for which the successful response is:  204 No Content  where the data was received and stored.  Typical PUT error responses would be:\n  -  401 Unauthorized : the client is not authenticated and\n      anonymous upload of the chunk is not supported.\n  -  403 Forbidden : the client is authenticated but does not have\n      sufficient privilege to upload the chunk.\n  -  400 Bad Request : the chunk number is not a non-negative integer.\n  -  409 Conflict : the chunk number is too large for the defined job.", 
            "title": "Chunk Upload"
        }, 
        {
            "location": "/REST-API/#chunked-upload-job-finalization", 
            "text": "The POST operation is used to signal completion of an upload job:  POST /namespace_path/object_name;upload/job_id\nHost: authority_name  for which the successful response is:  201 Created\nLocation: /namespace_path/object_name:version_id\nContent-Type: text/uri-list\nContent-Length: N\n\n/namespace_path/object_name:version_id  where  Location  includes the URL of the newly created object version\nthat is comprised of all the uploaded data chunks as if it had been\ncreated by a corresponding PUT request:  PUT /namespace_path/object_name\nHost: authority_name\nContent-Type: content_type\nContent-MD5: hash_value\nContent-Length: N\n\n...content...  Typical POST error responses would be:\n  -  401 Unauthorized  the client is not authenticated\n  -  403 Forbidden  the client is authenticated but does not have\n    sufficient privilege to finalize the upload.\n  -  409 Conflict  the currently uploaded content does not match the\n     Content-MD5  header of the original upload job. An implementation\n    MAY skip this validation but it is RECOMMENDED to perform this\n    validation rather than create broken objects.", 
            "title": "Chunked Upload Job Finalization"
        }, 
        {
            "location": "/REST-API/#chunked-upload-job-status-retrieval", 
            "text": "The GET operation is used to view the status of a pending upload:  GET /namespace_path/object_name;upload/job_id\nHost: authority_name  for which the successful response is:  200 OK\nContent-Type: application/json\nContent-Length: N\n\n{\"url\": \"/namespace_path/object_name;upload/job_id\",\n \"owner\": [\"role\"...],\n \"target\": \"/namespace_path/object_name\"\n \"chunk-length\": K,\n \"content-length\": N,\n ...\n}  summarizing the parameters set when the job was created including\noptional object metadata such as  content-type . Note, there is no\nsupport for determining which chunks have or have not been uploaded as\nsuch tracking is not a requirement placed on Hatrac implementations.", 
            "title": "Chunked Upload Job Status Retrieval"
        }, 
        {
            "location": "/REST-API/#chunked-upload-job-cancellation", 
            "text": "The DELETE method can be used to cancel an upload job that has not yet\nbeen finalized:  DELETE /namespace_path/object_name;upload/job_id\nHost: authority_name  for which the successful response is:  204 No Content  Once canceled, the job resource no longer exists and associated\nstorage SHOULD be reclaimed.", 
            "title": "Chunked Upload Job Cancellation"
        }
    ]
}